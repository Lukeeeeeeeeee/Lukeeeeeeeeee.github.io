<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cookie 和 SameSite 属性</title>
    <url>/2020/04/02/Cookie-%E5%92%8C-SameSite-%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>一般我们都会说“HTTP 是一个无状态的协议”，不过要注意这里的 HTTP 其实是指 HTTP 1.x，而所谓无状态协议，简单的理解就是即使同一个客户端连续两次发送请求给服务器，服务器也识别不出这是同一个客户端发送的请求，这导致的问题就比如你加入了一个商品到购物车中，但是因为识别不出时同一个客户端，刷新一下页面就没有了…</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>为了解决 HTTP 无状态导致的问题，后来出现了 Cookie。不过这样说可能会让你产生一些误解，首先无状态并不是不好，有优点，但也会导致一些问题。而 Cookie 的存在也不是为了解决通讯协议无状态的问题，只是为了解决客户端与服务器会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。</p>
<h4 id="Cookie-介绍"><a href="#Cookie-介绍" class="headerlink" title="Cookie 介绍"></a>Cookie 介绍</h4><p>引用维基百科：</p>
<blockquote>
<p>Cookie (复数形式 Cookies)，类型为[小型文本文件]，只某些网站为了辨别用户身份而储存在用户本地终端上的数据。</p>
</blockquote>
<p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称(Name)，一个值(Value)和其他几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成，这些涉及的属性后面会介绍。</p>
<h4 id="Cookie-的查看"><a href="#Cookie-的查看" class="headerlink" title="Cookie 的查看"></a>Cookie 的查看</h4><p>我们可以在浏览器的开发者工具中查看到当前页面的 Cookie：</p>
<p><img data-src="https://pic.downk.cc/item/5e85893f504f4bcb04d14eda.png" alt=""></p>
<p>尽管我们在浏览器里查看到了 Cookie，这并不意味着 Cookie 文件只是存放在浏览器里的。实际上，Cookie 相关的内容还可以存到本地文件里，就比如说 Mac 下的 Chrome，存放目录就是 <code>~/Library/Application Support/Google/Chrome/Default</code>，里面会有一个名为 Cookie 的数据库文件，你可以使用 sqlite 软件打开它。存放在本地的好处就在于即使你关闭了浏览器，Cookie 依然可以生效。</p>
<h4 id="Cookie-的设置"><a href="#Cookie-的设置" class="headerlink" title="Cookie 的设置"></a>Cookie 的设置</h4><p>那 Cookie 是怎么设置的呢？简单来说就是：</p>
<ol>
<li>客户端发送 HTTP 请求到服务器</li>
<li>当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段</li>
<li>浏览器收到响应后保存下来 Cookie</li>
<li>之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器</li>
</ol>
<p>以 <code>https://main.m.taobao.com/</code> 为例</p>
<p>请求返回的 Response Header 可以看到 Set-Cookie 字段</p>
<p><img data-src="https://pic.downk.cc/item/5e85aac3504f4bcb04eb5ba1.png" alt=""></p>
<p>再查看 Cookie</p>
<p><img data-src="https://pic.downk.cc/item/5e85ab4d504f4bcb04ebc3af.png" alt=""></p>
<p>可以在 Request Header 中看到 Cookie 字段</p>
<p><img data-src="https://pic.downk.cc/item/5e85abe5504f4bcb04ec369c.png" alt=""></p>
<h4 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h4><p>从下面这张图中，可以看到 Cookie 相关的一些属性</p>
<p><img data-src="https://pic.downk.cc/item/5e85ae03504f4bcb04edd13e.png" alt=""></p>
<p>需要注意的点：</p>
<h6 id="Name-Value"><a href="#Name-Value" class="headerlink" title="Name/Value"></a>Name/Value</h6><p>用于 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。</p>
<h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>Expires 用于设置 Cookie 的过期时间。</p>
<p><code>Set-Cookie: id=a3etds; Expires=Thu, 16 Apr 2020 06:21:20 GMT;</code></p>
<p>当缺少 Expires 属性时，表示是会话性 Cookie 如上图 Expires 的值为 Session，表示的就是会话性 Cookie，当为会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下，即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。</p>
<p>与会话性 Cookie 相对应的是持久性 Cookie，持久性 Cookie 会保存在用户的硬盘中，直到过期或者清除 Cookie。这里值得注意的是，设定的日期和时间只与客户端相关，而不是服务器。</p>
<h6 id="Max-Age"><a href="#Max-Age" class="headerlink" title="Max-Age"></a>Max-Age</h6><p>Max-Age 用于设置在 Cookie 失效之前需要经过的秒数。</p>
<p><code>Set-Cookie: id=a3etds; Max-Age=604800;</code></p>
<p>Max-Age 可以是正数、负数甚至是 0.<br>如果 Max-Age 属性为正数，浏览器会将其持久化，即写到对应的 Cookie 文件中。<br>如果 Max-Age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。<br>如果 Max-Age 属性为 0，则会立即删除这个 Cookie。</p>
<p>假如 Expires 和 Max-Age 都存在，则 Max-Age 优先级更高。</p>
<h6 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h6><p>Domain 指定了 Cookie 可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分(但是不包含子域名);</p>
<p>像淘宝首页设置的 Domain 就是 .taobao.com，这样无论是 a.taobao.com 还是 b.taobao.com 都可以使用 Cookie。</p>
<p>需要注意的是，不能跨域设置 Cookie。</p>
<h6 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h6><p>Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。比如设置 <code>Path=/a</code>, <code>/a/b</code> 下的资源会带 Cookie 首部，<code>/c</code>则不会携带 Cookie 首部。</p>
<p>Domain 和 Path 标志共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
<h6 id="Secure-属性"><a href="#Secure-属性" class="headerlink" title="Secure 属性"></a>Secure 属性</h6><p>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。</p>
<h6 id="HTTPOnly"><a href="#HTTPOnly" class="headerlink" title="HTTPOnly"></a>HTTPOnly</h6><p>设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。</p>
<h6 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h6><p>SameSite 是最近非常值得一提的内容，因为 2 月份发布的 Chrome 80 版本中默认屏蔽了第三方的 Cookie。</p>
<h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><p>SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击。</p>
<h5 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h5><p>SameSite 可以有下面三种值：</p>
<ul>
<li><p><strong>Strict</strong> 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致</p>
</li>
<li><p><strong>Lax</strong> 允许部分第三方请求携带 Cookie</p>
</li>
<li><p><strong>None</strong> 无论是否跨站都会发送 Cookie</p>
</li>
</ul>
<p>之前默认是 None，Chrome 80 后默认为 Lax。</p>
<h6 id="跨域和跨站"><a href="#跨域和跨站" class="headerlink" title="跨域和跨站"></a>跨域和跨站</h6><p>首先要理解的一点就是<strong>跨站</strong>和<strong>跨域</strong>是不同的。[同站(same-site)/跨站(cross-site)] 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83ZTdkNDFjZDJiYWM=" title="https://www.jianshu.com/p/7e7d41cd2bac">第一方(first-party)/第三方(third-party)<i class="fa fa-external-link"></i></span>是等价的。但是与浏览器同源策略(SOP)中的[同源(same-origin)/跨域(cross-origin)]是完全不同的概念。</p>
<p>同源策略的同源是指两个 URL 的协议/域名/端口一致。例如，<span class="exturl" data-url="aHR0cHM6Ly93d3cudGFvYmEuY29tL3BhZ2VzLy4uLu+8jOWug+eahOWNj+iuruaYrw==" title="https://www.taoba.com/pages/...，它的协议是">https://www.taoba.com/pages/...，它的协议是<i class="fa fa-external-link"></i></span> <code>https</code>，域名是 <code>www.taobao.com</code>，端口是 <code>443</code>。</p>
<p>同源策略作为浏览器的安全基石，其[同源]判断是比较严格的，相对而言，Cookie 中的 [同站]判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表(Public Suffix List)中，例如，.com、.co.uk、.github.io 等。eTLD+1 则表示，有效顶级域名 + 二级域名，例如 <code>taobao.com</code>。</p>
<p>举几个例子，<code>www.taobao.com</code> 和 <code>www.baidu.com</code> 是跨站，<code>www.a.taobao.com</code> 和 <code>www.b.taobao.com</code> 是同站，<code>a.github.io</code> 和 <code>b.github.io</code> 是跨站(注意是跨站。有效顶级域名：.github.io，二级域名不同)</p>
<h6 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h6><p>接下来看下从 None 改成 Lax 到底影响了哪些地方的 Cookie 的发送?</p>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>实例</th>
<th>以前</th>
<th>Strict</th>
<th>Lax</th>
<th>None</th>
</tr>
</thead>
<tbody><tr>
<td>链接</td>
<td><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>发送 cookie</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>预加载</td>
<td><code>&lt;link ref=&quot;prerender&quot; href=&quot;...&quot; /&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>发送 cookie</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>get 表单</td>
<td><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>发送 cookie</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>post 表单</td>
<td><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>不发送</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>iframe</td>
<td><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>不发送</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>AJAX</td>
<td><code>$.get(&quot;...&quot;)</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>不发送</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>Image</td>
<td><code>&lt;img src=&quot;...&quot;&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>不发送</td>
<td>发送 cookie</td>
</tr>
</tbody></table>
<p>从上表可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站发送第三方 Cookie，改变成不发送。</p>
<p>Post 表单：应该的，学 CSRF 总会据表单的例子。</p>
<p>iframe：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响。</p>
<p>AJAX：可能会影响到部分前端取值的行为和结果。</p>
<p>Image：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受影响。</p>
<p>除了这些还有 script 的方式，这种方式也不会发送 Cookie，像淘宝的大部分请求都是 jsonp，如果涉及到跨站也有可能会被影响。</p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>解决方案就是设置 SameSite 为 none。</p>
<p>不过也有两点要注意的地方：</p>
<ul>
<li>HTTP 接口不支持 SameSite = none</li>
</ul>
<p>如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。</p>
<ul>
<li>需要 UA 监测，部分浏览器不能加 SameSite=none</li>
</ul>
<p>IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务器必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性。</p>
<h6 id="Cookie-的作用"><a href="#Cookie-的作用" class="headerlink" title="Cookie 的作用"></a>Cookie 的作用</h6><ol>
<li>会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)</li>
<li>个性化设置(如用户自定义设置、主题等)</li>
<li>浏览器行为跟踪(如跟踪分析用户行为等)</li>
</ol>
<h6 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h6><ol>
<li>储存空间很小(只有4KB - 10KB左右)</li>
<li>安全性不够高，可能被截取篡改</li>
<li>有些状态不可能保存在客户端，如为了防止重复提交表单，需要在服务器端保存一个计数器。如果计数器保存在客户端，那么就没有任何作用。</li>
</ol>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21xeXFpbmdmZW5nL0Jsb2cvaXNzdWVzLzE1Nw==" title="https://github.com/mqyqingfeng/Blog/issues/157">https://github.com/mqyqingfeng/Blog/issues/157<i class="fa fa-external-link"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub加载过慢或图片加载失败</title>
    <url>/2020/06/03/Github%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>通过 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaXBhZGRyZXNzLmNvbS8=" title="https://www.ipaddress.com/">ip地址查询<i class="fa fa-external-link"></i></span> 查看 GitHub 的 ip。</p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>在 Mac 下执行 <code>sudo vim /etc/hosts</code> 命令修改 hosts 文件。随便按一个键，进入 INSERT 模式，在最后一行添加如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GitHub Start</span><br><span class="line">140.82.114.4      github.com</span><br><span class="line">140.82.114.20     gist.github.com</span><br><span class="line">140.82.113.4      gist.github.com</span><br><span class="line"></span><br><span class="line">151.101.184.133    assets-cdn.github.com</span><br><span class="line">151.101.184.133    raw.githubusercontent.com</span><br><span class="line">151.101.184.133    gist.githubusercontent.com</span><br><span class="line">151.101.184.133    cloud.githubusercontent.com</span><br><span class="line">151.101.184.133    camo.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars0.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars0.githubusercontent.com</span><br><span class="line">199.232.28.133     avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars2.githubusercontent.com</span><br><span class="line">199.232.28.133     avatars2.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars3.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars3.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars4.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars4.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars5.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars5.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars6.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars6.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars7.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars7.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars8.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars8.githubusercontent.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure>

<p>添加完毕后，按 ESC 键退出 INSERT 模式，输入 <code>:wq</code> 命令退出。</p>
<p>注意：当出现 GitHub 加载过慢或者图片加载失败时，通过控制台查看该网址并通过上面的 ip地址查询网站 中查看对应的 ip地址，将它添加到 hosts 文件中即可。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>暂时还没尝试。</p>
]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础学习-不可变的原始值和可变的对象引用</title>
    <url>/2020/05/21/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%92%8C%E5%8F%AF%E5%8F%98%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h3 id="JavaScript的原始值和对象-基本类型和引用类型"><a href="#JavaScript的原始值和对象-基本类型和引用类型" class="headerlink" title="JavaScript的原始值和对象(基本类型和引用类型)"></a>JavaScript的原始值和对象(基本类型和引用类型)</h3><p>JavaScript的基础类型(原始值)：undefined、null、string、number、boolean、symbol</p>
<h4 id="原始值和对象区别："><a href="#原始值和对象区别：" class="headerlink" title="原始值和对象区别："></a>原始值和对象区别：</h4><ul>
<li>原始值是不可改变的，任何方法都不可改变一个原始值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s.toUpperCase();    <span class="comment">// 返回 HELLO，但是并没有改变 s 的值</span></span><br><span class="line">s                   <span class="comment">// =&gt; hello，原始值并未发生改变</span></span><br></pre></td></tr></table></figure>

<h4 id="原始值和对象的比较"><a href="#原始值和对象的比较" class="headerlink" title="原始值和对象的比较"></a>原始值和对象的比较</h4><p>原始值的比较是值的比较。<br>对象的比较并非是值的比较：即使两个对象包含同样的属性及同样的值，也是不相等的。</p>
<p>对象值是引用，对象的比较是引用的比较：当且仅当它们指向同一个地址内存，它们才相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">0</span>];       <span class="comment">// =&gt; 1</span></span><br><span class="line">a === b;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>用一道题来结束：如何通过比较数组的每个元素判断两个数组是否相等？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equalArray</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length != b.length) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 两个数组长度不同，肯定不相等</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] !== b[i]) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// 如果有任意元素不等，这两个数组就不想等</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础学习-作用域</title>
    <url>/2020/05/22/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="变量作用域和函数作用域"><a href="#变量作用域和函数作用域" class="headerlink" title="变量作用域和函数作用域"></a>变量作用域和函数作用域</h3><p>全局变量的作用域就是全局，无论在哪里都可以使用。</p>
<p>函数内声明的变量，其作用域只在函数内(包括内嵌函数)可以使用。<br>别忘了，函数的参数，其作用域也是函数内部。<br>在函数内部，局部变量优先级高于同名的全局变量。如果一个函数的内部声明了一个局部变量或者函数带有的参数和全局变量同名，那么全局变量就会被局部变量或者参数覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkoutscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkoutscope(); <span class="comment">// =&gt; 'local'</span></span><br></pre></td></tr></table></figure>

<p>注意：全局变量可以不用 var 来声明，但是局部变量必须使用 var 来声明，否则会出现意想不到的bug。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scope = <span class="string">'local'</span>;</span><br><span class="line">    myscope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="keyword">return</span> [scope, myscope];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkscope2();  <span class="comment">// =&gt; ['local', 'local']</span></span><br><span class="line">scope <span class="comment">// =&gt; 'local'</span></span><br><span class="line">myscope <span class="comment">// =&gt; 'local'</span></span><br></pre></td></tr></table></figure>

<p>最后，让我们来看一看，函数嵌套的作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkoutscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nested</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> scope = <span class="string">'nested'</span>;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nested();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkoutscope(); <span class="comment">// =&gt; 'nested'</span></span><br></pre></td></tr></table></figure>

<h3 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h3><p>先看一段代码，猜猜它输出的结果是什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkoutscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>// =&gt; undefined<br>// =&gt; ‘local’</p>
<p>为什么呢？全局变量不是可以在任何地方都可以使用嘛？其实是没错的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkoutscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// =&gt; 'global'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们在上面还有一句话，<strong>当函数内的局部变量与全局变量同名，局部变量优先级高于全局变量</strong>。其实，一开始的那段代码与下面这段是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkoutscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope;</span><br><span class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// =&gt; undefined</span></span><br><span class="line">    scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// =&gt; 'local'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中通过 var 声明的变量会将其提升到最顶部，当运行到 var 语句时，才会被真正的赋值。</p>
<p>小知识：</p>
<p>当声明一个 JavaScript 全局变量时，实际上是给全局对象定义了一个属性：也就是在浏览器中，可以通过 window.[变量名] 的方式获取。<br>var 声明的变量是不可配置的，也就是说它是不可以被删除的，而直接给一个没有声明的变量赋值的话，JavaScript 会自动创建一个全局变量，但却可以删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">1</span>;</span><br><span class="line">test2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.test3 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> test; <span class="comment">// =&gt; false：变量并没有被删除</span></span><br><span class="line"><span class="keyword">delete</span> test2; <span class="comment">// =&gt; true：被删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.test3; <span class="comment">// =&gt; true：被删除</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础学习-关系表达式</title>
    <url>/2020/05/24/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>这里不具体介绍所有的，主要介绍下 instanceof 运算符的运行原理。</p>
<p>关系表达式有：==、 ===、 !=、 !==、 &lt;、 &gt;、 &lt;=、 &gt;=、 in、 instanceof</p>
<h3 id="in-运算发"><a href="#in-运算发" class="headerlink" title="in 运算发"></a>in 运算发</h3><p>其中 in 运算符是用来检测对象中是否存在某个属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="string">'x'</span> <span class="keyword">in</span> point; <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="string">'z'</span> <span class="keyword">in</span> point; <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> point <span class="comment">// =&gt; true: 对象继承了 toString() 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="string">'0'</span> <span class="keyword">in</span> data; <span class="comment">// =&gt; true: 0 在数组的索引中</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> data; <span class="comment">// =&gt; true: 数字转换成字符串</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> data; <span class="comment">// =&gt; false: 没有索引为 3 的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>instanceof 运行原理：为了计算表达式 o instanceof f，JavaScript 首先计算 f.prototype，然后在原型链中查找 o，如果找到，那么 o 是 f 的一个实例，返回 true。<br>如果 f.prototype 不在 o 的原型链中的话，那么 o 不是 f 的实例，返回 false。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础学习-函数</title>
    <url>/2020/06/02/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>关于 this：如果嵌套函数作为方法调用，其 this 值指向调用它的对象。如果嵌套函数作为函数调用，其 this 值不是全局对象就是 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础学习-对象</title>
    <url>/2020/05/24/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每一个 JavaScript 对象(除了 null)都和另一个对象相关联。“另一个”对象就是我们所熟知的原型，每一个对象都从原型继承属性。</p>
<p>所有通过对象直接量创建的对象都具有同一个原型对象，并且可以通过 JavaScript 代码 Object.prototype 获取对原型对象的引用。<br>通过 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// =&gt; true</span></span><br><span class="line">newObj.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> newArr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">arr.__proto__ === <span class="built_in">Array</span>.prototype <span class="comment">// =&gt; true</span></span><br><span class="line">newArr.__proto__ === <span class="built_in">Array</span>.prototype <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>注意：没有原型的对象不多，Object.prototype 就是其中之一。它不继承任何属性。</p>
<p>另外，还可以通过 Objec.create() 方法基于一个对象的原型，创建一个新对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;); <span class="comment">// o1 继承了属性 x 和 y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>); <span class="comment">// 通过传入 null，来创建一个不继承任何属性和方法的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype); <span class="comment">// o3 和 &#123;&#125;、new Object() 一样，创建了一个空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * inherit() 返回一个继承继承自对象 p 的属性的新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create) <span class="keyword">return</span> <span class="built_in">Object</span>.create(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> p;</span><br><span class="line">    <span class="keyword">if</span>(t !== <span class="string">'object'</span> &amp;&amp; t !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    f.prototype = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h3><p>常用的检测属性的方法有：in 运算符、hasOwnProperty()、属性查询<br>此外还有一个：propertyIsEnumerable()方法</p>
<p>in 运算符不在介绍</p>
<p>hasOwnProperty() 方法用来检测是否是自身属性，对于继承属性返回 false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">o.hasOwnProperty(<span class="string">'x'</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">'y'</span>); <span class="comment">// =&gt; false</span></span><br><span class="line">o.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// =&gt; false: toString() 方法是继承属性</span></span><br></pre></td></tr></table></figure>

<p>propertyIsEnumerable() 方法是 hasOwnProperty() 的增强版，只检测自身属性并且该属性是可枚举的才返回 true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = inherit(&#123;<span class="attr">y</span>: <span class="number">2</span>&#125;);</span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">'x'</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'y'</span>); <span class="comment">// =&gt; false：y 是继承来的</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.propertyIsEnumerable(<span class="string">'toString'</span>); <span class="comment">// =&gt; false: 不可枚举</span></span><br></pre></td></tr></table></figure>

<p>属性查询，判断是不是 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">o.x !== <span class="literal">undefined</span>; <span class="comment">// =&gt; true</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>; <span class="comment">// =&gt; false</span></span><br><span class="line">o.toString !== <span class="literal">undefined</span>; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>写到这里有同学就会问如果 o 对象的 x 值，我显示给 undefined 上面的方法不就不能区分了嘛？没错，所以遇到这种情况，则只能使用 in 运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">o.x !== <span class="literal">undefined</span>; <span class="comment">// false</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>; <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 上面不能区分哪个属性不存在 o 对象中</span></span><br><span class="line"><span class="string">'x'</span> <span class="keyword">in</span> o; <span class="comment">// true</span></span><br><span class="line"><span class="string">'y'</span> <span class="keyword">in</span> o; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">delete</span> o.x;</span><br><span class="line"><span class="string">'x'</span> <span class="keyword">in</span> o; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>所以通常情况下，使用 in 运算符就可以了。</p>
<h3 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h3><p>for/in 循环可以遍历对象的所有<strong>可枚举属性</strong>(包括自身属性和继承属性)。</p>
<p>除了 for/in 循环外，还有 Object.keys()，它返回一个数组，这个数组由对象中可枚举的自身属性的名称(key)组成。</p>
<p>Object.getOwnPropertyNames() 返回对象中的所有自身属性的名称，包括不可枚举属性。</p>
<h3 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h3><p>数据属性的四个特性：值(value)、可写(writable)、可配置(configurable)、可枚举(enumerable)<br>存取器属性的四个特性：读取(get)、写入(set)、可配置、可枚举</p>
<p>Object.getOwnPropertyDescriptor() 可以获取某个对象自有属性的属性描述符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, <span class="string">'x'</span>); <span class="comment">// &#123;value: 1, writable: true, configurable: true, enumerable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span> = </span>&#123;</span><br><span class="line">   <span class="keyword">get</span> octet() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(random, <span class="string">'octet'</span>); <span class="comment">// &#123;get: /* func */, set: undefined, configurable: true, enumerable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于不存在的属性和继承属性，返回 undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">'x'</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">'toString'</span>); <span class="comment">// undefined, 继承属性</span></span><br></pre></td></tr></table></figure>

<p>如果要想获取继承属性的特性，需要遍历原型链，使用 Object.getPropertyOf()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPropertyOf(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>要想检测一个对象是否是另一个对象的原型(或处于原型链)，可以通过 Object.isPropertyOf() 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 p.isPropertyOf(o) 来检测 p 是否是 o 的原型</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(p);</span><br><span class="line">p.isPropertyOf(o); <span class="comment">// =&gt; true: o 继承 p</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPropertyOf(o) <span class="comment">// =&gt; true: p 继承自 Object.prototype</span></span><br></pre></td></tr></table></figure>


<p>如果想要设置属性的特性，或者想让某个新建属性具有某种特性，可以通过调用 Object.defineProperty(要修改的对象, 要创建或者修改的属性名称，属性描述符对象)</p>
<p>注意：此方法不能修改继承属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'x'</span>, &#123;</span><br><span class="line">   value: <span class="number">1</span>,</span><br><span class="line">   wriable: <span class="literal">true</span>,</span><br><span class="line">   configurable: <span class="literal">true</span>,</span><br><span class="line">   enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性存在，但是不可以枚举</span></span><br><span class="line">o.x; <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">Object</span>.keys(o); <span class="comment">// =&gt; []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在对属性 x 做修改，让它变成只读</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'x'</span>, &#123; <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line">o.x = <span class="number">2</span>; <span class="comment">// 无法改变且不会报错，在严格模式下会抛出类型错误异常</span></span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但属性却是可以配置的，因此通过下面这种方式，还是可以改变值的</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'x'</span>, &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;);</span><br><span class="line">o.x; <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在将 x 从数据属性改为存取器属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'x'</span>, &#123; <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; &#125;);</span><br><span class="line">o.x; <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure>

<p>如果通过 Object.defineProperty() 新创建了一个值，那么它的默认特性值是 undefined 或者 false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">'x'</span>); <span class="comment">// &#123;value: undefined, writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果同时修改多个值，需要使用 Object.defineProperties(要修改的对象, 映射表)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.definedProperties(&#123;&#125;, &#123;</span><br><span class="line">   x: &#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">   y: &#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">   r: &#123;</span><br><span class="line">      <span class="keyword">get</span>: function() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.x * <span class="keyword">this</span>.x + <span class="keyword">this</span>.y * <span class="keyword">this</span>.y)</span><br><span class="line">      &#125;,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>关于 Object.defineProperty() 和 Object.defineProperties() 相关规则：</p>
<ul>
<li>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性</li>
<li>如果属性是不可配置的，则不能修改它的可配置性和可枚举性</li>
<li>如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换成数据属性</li>
<li>如果数据属性是不可配置的，则不能将它转换成存取器属性，也不能将它的可写性从 false 修改为 true，但可以从 true 修改为 false</li>
<li>如果数据属性是不可配置且不可写的，则不能修改它的值。</li>
<li>如果数据属性是可配置但不可写，属性的值确实可以修改的(因为是可以配置的，所以先将它标记为可写的，然后修改它的值，最后在转换成不可写的)</li>
</ul>
<p>简单概括：</p>
<ol>
<li>可写性控制着对值特性的修改</li>
<li>可配置性控制着对其他特性(包括属性是否可以删除)的修改</li>
<li>如果属性可配置的话，则可以修改不可写属性的值</li>
<li>如果属性是不可配置的，则仍然可以将可写属性修改为不可写属性</li>
</ol>
<p>根据这些了解的内容，我们创建一个可以复制属性的特性的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给 Object.prototype 添加一个不可枚举的 extend() 方法</span></span><br><span class="line"><span class="comment"> * 这个方法继承自调用它的对象，将作为参数传递的对象的属性一一复制</span></span><br><span class="line"><span class="comment"> * 除了值以外，也复制属性的所有特性，除非在目标对象中存在同名的属性，</span></span><br><span class="line"><span class="comment"> * 参数对象的所有自有对象(包括不可枚举的属性)也会一一复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'extend'</span>, &#123;</span><br><span class="line">   writable: <span class="literal">true</span>,</span><br><span class="line">   configurable: <span class="literal">true</span>,</span><br><span class="line">   enumerable: <span class="literal">false</span>,</span><br><span class="line">   value: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 得到所有的自有属性，包括不可枚举属性</span></span><br><span class="line">      <span class="keyword">var</span> names = <span class="built_in">Object</span>.getOwnPropertyNames();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">         <span class="comment">// 如果属性已经存在，则跳过</span></span><br><span class="line">         <span class="keyword">if</span> (names[i] <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="comment">// 获取 o 中的属性的描述符</span></span><br><span class="line">         <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, names[i]);</span><br><span class="line">         <span class="comment">// 用它给 this 创建一个属性</span></span><br><span class="line">         <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, names[i], desc);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>对象的类属性是一个字符串，用以表示对象的类型信息。格式：[object class]。以下函数就可以返回传递给它的任意对象的类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">'Null'</span>;</span><br><span class="line">   <span class="keyword">if</span> (o === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">'Undefined'</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过对象直接量和 Object.create() 方法创建的对象的类属性是 'Object'，同时那些自定义的构造函数创建的对象也是 'Object'，因此对于自定义的类，没办法通过类属性区分对象的类：</span></span><br><span class="line">classof(<span class="literal">null</span>);          <span class="comment">// =&gt; 'Null'</span></span><br><span class="line">classof(<span class="literal">undefined</span>);     <span class="comment">// =&gt; 'Undefined'</span></span><br><span class="line">classof(<span class="number">1</span>);             <span class="comment">// =&gt; 'Number'</span></span><br><span class="line">classof(<span class="string">''</span>);            <span class="comment">// =&gt; 'String'</span></span><br><span class="line">classof(<span class="literal">false</span>);         <span class="comment">// =&gt; 'Boolean'</span></span><br><span class="line">classof(&#123;&#125;);            <span class="comment">// =&gt; 'Object'</span></span><br><span class="line">classof([]);            <span class="comment">// =&gt; 'Array'</span></span><br><span class="line">classof(<span class="regexp">/./</span>);           <span class="comment">// =&gt; 'Regexp'</span></span><br><span class="line">classof(<span class="keyword">new</span> <span class="built_in">Date</span>());    <span class="comment">// =&gt; 'Date'</span></span><br><span class="line">classof(<span class="built_in">window</span>);        <span class="comment">// =&gt; 'Window'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">classof(<span class="keyword">new</span> f());       <span class="comment">// =&gt; 'Object'</span></span><br></pre></td></tr></table></figure>

<p>注意：除了数字，字符串、布尔值和对象是可以直接调用 toString() 方法的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>toString(); <span class="comment">// 报错，因为 '.' 被当作小数点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a.toString(); <span class="comment">// =&gt; '1'</span></span><br><span class="line"></span><br><span class="line"><span class="string">''</span>.toString(); <span class="comment">// =&gt; ""</span></span><br><span class="line"><span class="literal">true</span>.toString(); <span class="comment">// =&gt; 'true'</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.seal(</span><br><span class="line">   <span class="built_in">Object</span>.create(</span><br><span class="line">      <span class="built_in">Object</span>.freeze(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;),</span><br><span class="line">      &#123; <span class="attr">y</span>: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">true</span> &#125; &#125;</span><br><span class="line">   )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>通过 Object.isExtensible() 方法判断该对象是否是可扩展的。</p>
<p>如果想将对象转换为不可扩展的，可以调用 Object.preventExtensions() 方法，将待转换的对象作为参数传递进去。<br>注意，一旦将对象转换为不可扩展的，就无法再将其转换成可扩展的了。<br>一般来说，不可扩展对象的属性仍然是可被删除的。<br>同样需要注意的是，Object.preventExtensions() 影响只是对象本身的可扩展性。如果给一个不可扩展的对象的原型添加属性，不可扩展的对象还是会继承这些新属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(object1);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="built_in">Object</span>.defineProperty(object1, <span class="string">'property1'</span>, &#123;</span><br><span class="line">      value: <span class="number">42</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(e); <span class="comment">// TypeError: Cannot define property property1, object is not extensible</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> object1.x; <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line">object1.x; <span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>

<p>通过 Object.isSealed() 来检测对象是否是封闭的。</p>
<p>Object.seal() 和 Object.preventExtensions() 相似，但是 Object.seal() 还将对象设置为不可配置的。<br>也就是说不能给这个对象添加新属性，同时它已有的属性也不能删除和配置，不过它已有的属性是可写的，则仍然可以设置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.seal(object1);</span><br><span class="line">object1.x = <span class="number">33</span>;</span><br><span class="line"><span class="built_in">console</span>.log(object1.x); <span class="comment">// =&gt; 33</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> object1.x;</span><br><span class="line"><span class="built_in">console</span>.log(object.x); <span class="comment">// =&gt; 33</span></span><br></pre></td></tr></table></figure>

<p>通过 Object.isFrozen() 来检测对象是否冻结。</p>
<p>Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；不能像这个对象添加属性、不能删除已有的属性，不能修改该对象已有的属性的可配置性、可扩展性、可枚举性以及不可修改已有属性的值。<br>此外，冻结一个对象后该对象的原型也不能被修改。(如果对象的存取器属性具有 setter 方法，存取器则不受影响，仍然可以给属性赋值调用它们)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.x = <span class="number">33</span>; <span class="comment">// Throws an error in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.x); <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的其他方法"><a href="#对象的其他方法" class="headerlink" title="对象的其他方法"></a>对象的其他方法</h3><p>Object.assign() 方法会浅拷贝一个对象</p>
<p>Object.entries() 方法会返回一个给定对象自身可枚举属性的键值对数组，与 for…in 的区别是不会枚举原型中的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">   x: <span class="number">1</span>,</span><br><span class="line">   y: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(o)) <span class="comment">// [ [ 'x', 1 ], [ 'y', 2 ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> (<span class="built_in">Object</span>.entries(o))) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>, <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x, 1</span></span><br><span class="line"><span class="comment">// y, 2</span></span><br></pre></td></tr></table></figure>

<p>Object.toString() 方法返回一个该对象的字符串</p>
<p>Object.toLocaleString() 方法返回一个表示这个对象的本地化字符串</p>
<p>Object.is() 方法判断两个值是否是相同的值。</p>
<p>判断依据：</p>
<ul>
<li>两个值都是 undefined</li>
<li>两个值都是 null</li>
<li>两个值都是 true 或 false</li>
<li>两个值是由相同个数的字符按照相同的顺序组成的字符串</li>
<li>两个值指向同一个对象</li>
<li>两个值都是数字并且<ul>
<li>都是正零 +0</li>
<li>都是负零 -0</li>
<li>都是 NaN</li>
<li>都是除零和 NaN 外的其它同一个数字</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>);   <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="built_in">window</span>, <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'bar'</span>);   <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">Object</span>.is([], []);         <span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.is(foo, foo);       <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">Object</span>.is(foo, bar);       <span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>);       <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>;                <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>;               <span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">-0</span>);          <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, +<span class="number">0</span>);          <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">-0</span>);         <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span>/<span class="number">0</span>);       <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="number">0</span> == <span class="number">-0</span>;                   <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="number">0</span> === <span class="number">-0</span>;                  <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>Object.values() 方法返回一个给定对象自身的所有可枚举属性值的数组，不可枚举属性不会获取到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj));    <span class="comment">// ['bar', 42]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(<span class="string">'foo'</span>));  <span class="comment">// ['f', 'o', 'o']</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础学习-数组</title>
    <url>/2020/06/01/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>这里不对每个方法进行讲解。</p>
<p>join() 方法可以将数组所有的元素转化为字符串并拼接在一起，返回最后生成的字符串。</p>
<p>reverse() 方法可以将数组颠倒顺序，返回逆向的数组。注意：它会改变原数组。</p>
<p>sort() 方法将数组排序，返回排序后的数组。注意：第一个参数与第二个参数相减，小于0，排在前面，反之排在后面，等于0，则不需要变换。undefined 排在最后。</p>
<p>concat() 方法合并数组，返回一个新的数组。</p>
<p>slice() 方法返回指定数组的一个片段或子数组。注意：相当于浅拷贝一个数组。</p>
<p>splice() 方法是在数组中插入或者删除元素的通用方法。注意：会改变原数组，第二个参数如果是 -1 代表最后一个元素。</p>
<p>push() 和 pop() 方法前一个是向数组的尾部添加元素，后一个方法是删除数组的最后一个元素。注意：都会改变原数组。</p>
<p>unshift() 和 shift() 方法前一个是向数组的头部添加元素，后一个是删除数组的第一个元素并返回。注意：都会改变原数组。</p>
<p>以下也是数组的方法，是 ECMAScript5 新增的方法。注意：大多数方法的第一个参数接受一个函数，函数的参数通常为数组元素、索引和数组本省</p>
<p>forEach() 方法从头到尾的遍历数组，为每个元素调用指定的函数。注意：通常情况下，不会改变原数组，如果原数组中有引用类型，不能确保不会改变。与 for 循环不同，它不可以通过 break 语句提前终止，如果需要终止，只能抛出异常。</p>
<p>map() 方法返回一个新数组。</p>
<p>filter() 方法返回符合传入条件为 true 的数组。注意：filter() 会跳过稀疏数组中缺少的元素。</p>
<p>every() 和 some() 方法前一个是当且仅当数组中的所有元素都满足条件才返回 true，后一个当数组中至少存在一个符合条件的元素就会返回 true；并且当且仅当数组中的所有元素都不符合条件才返回 false。注意：对于空数组，every() 返回 true，some() 返回 false。</p>
<p>reduce() 和 reduceRight() 方法将数组元素进行组合，生成单个值。对于空数组，reduce() 方法会导致类型错误异常。reduceRight() 是从右向左处理数组。</p>
<p>indexOf() 和 lastIndexOf() 方法所有整个数组，返回找到的第一个元素的索引，如果没有找到则返回 -1。前一个方法从头到尾，后一个方法则相反。</p>
<p>isArray() 方法判断是否是数组。</p>
<p>实现一个 Array.isArray() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Function</span>.isArray || <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础学习-类型转换</title>
    <url>/2020/05/21/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="类型转换表"><a href="#类型转换表" class="headerlink" title="类型转换表"></a>类型转换表</h3><table>
<thead>
<tr>
<th>值</th>
<th>转换为：字符串</th>
<th>数字</th>
<th>布尔值</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>‘undefined’</td>
<td>NaN</td>
<td><strong>false</strong></td>
<td>throws TypeError</td>
</tr>
<tr>
<td>null</td>
<td>‘null’</td>
<td>0</td>
<td><strong>false</strong></td>
<td>throws TypeError</td>
</tr>
<tr>
<td>true</td>
<td>‘true’</td>
<td>1</td>
<td></td>
<td>new Boolean(true)</td>
</tr>
<tr>
<td>false</td>
<td>‘false’</td>
<td>0</td>
<td></td>
<td>new Boolean(false)</td>
</tr>
<tr>
<td>‘’(空字符串)</td>
<td></td>
<td>0</td>
<td><strong>false</strong></td>
<td>new String(‘’)</td>
</tr>
<tr>
<td>‘1.2’</td>
<td></td>
<td>1.2</td>
<td>true</td>
<td>new Number(1.2)</td>
</tr>
<tr>
<td>‘one’</td>
<td></td>
<td>NaN</td>
<td>true</td>
<td>new String(‘one’)</td>
</tr>
<tr>
<td>0</td>
<td>‘0’</td>
<td>0</td>
<td><strong>false</strong></td>
<td>new Number(0)</td>
</tr>
<tr>
<td>-0</td>
<td>‘0’</td>
<td>0</td>
<td><strong>false</strong></td>
<td>new Number(-0)</td>
</tr>
<tr>
<td>NaN</td>
<td>‘NaN’</td>
<td></td>
<td><strong>false</strong></td>
<td>new Number(NaN)</td>
</tr>
<tr>
<td>Infinity</td>
<td>‘Infinity’</td>
<td></td>
<td>true</td>
<td>new Number(Infinity)</td>
</tr>
<tr>
<td>-Infinity</td>
<td>‘-Infinity’</td>
<td></td>
<td>true</td>
<td>new Nubmer(-Infinity)</td>
</tr>
<tr>
<td>1(无穷大, 非零)</td>
<td>‘1’</td>
<td>1</td>
<td>true</td>
<td>new Nubmer(1)</td>
</tr>
<tr>
<td>{} (任意对象)</td>
<td>注 1<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></td>
<td>注 2<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>[] (任意数组)</td>
<td>‘’</td>
<td>0</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>[9] (1个数字元素)</td>
<td>‘9’</td>
<td>9</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>[‘a’] (其他数组)</td>
<td>注 3<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></td>
<td>NaN</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>function(){}(任意函数)</td>
<td>注 4<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></td>
<td>NaN</td>
<td>true</td>
<td></td>
</tr>
</tbody></table>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">会先调用 toString()，如果没有，则调用 valueOf()，都没有则抛出类型错误异常</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">会先调用 valueOf()，如果没有，则调用 toString()，都没有则抛出类型错误异常</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">调用 join()，如['a'] =&gt; 'a', [1,2,3] =&gt; '1,2,3'</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">调用 toString()</span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一道关于JavaScript综合面试题</title>
    <url>/2020/03/30/%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8EJavaScript%E7%BB%BC%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>以下是我之前确实面试过的一道题，当时答的很不好，事后也想不起来了，正好前两天看到一个公众号发出来了，把思路也给捋清楚了，就记录到这里了。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName &#x3D; function() &#123; alert(1); &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function() &#123; alert(2); &#125;</span><br><span class="line">Foo.prototype.getName &#x3D; function() &#123; alert(3); &#125;</span><br><span class="line">var getName &#x3D; function() &#123; alert(4); &#125;</span><br><span class="line">function getName() &#123; alert(5); &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请写出一下输出结果</span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line">new Foo.getName();</span><br><span class="line">new Foo().getName();</span><br><span class="line">new new Foo().getName();</span><br></pre></td></tr></table></figure>

<h4 id="Foo-getName"><a href="#Foo-getName" class="headerlink" title="Foo.getName();"></a>Foo.getName();</h4><p>让我们来分析下，<br>首先定义了一个 Foo 函数，<br>之后为 Foo 创建了一个叫 getName 的静态属性并赋值一个匿名函数，<br>之后为 Foo 的原型对象新创建了一个叫 getName 的匿名函数。<br>创建了一个名为 getName 函数表达式，<br>声明了一个 getName 函数。</p>
<p>第一问，Foo 函数也是对象，所以自然访问的就是函数上的静态属性，即<code>Foo.getName = function() { alert(2); }</code>;</p>
<p>以下例子用来加深理解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">    var name &#x3D; name; &#x2F;&#x2F; 私有属性</span><br><span class="line">    this.name &#x3D; name; &#x2F;&#x2F; 公开属性</span><br><span class="line">    function getName() &#123; &#x2F;&#x2F; 私有方法</span><br><span class="line">        alert(1);</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.getName &#x3D; function() &#123; &#x2F;&#x2F; 公有方法</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;</span><br><span class="line">User.name &#x3D; &#39;user&#39;; &#x2F;&#x2F; 静态属性</span><br><span class="line">User.getName &#x3D; function() &#123; &#x2F;&#x2F; 静态方法</span><br><span class="line">    alert(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getName"><a href="#getName" class="headerlink" title="getName();"></a>getName();</h4><p>第二问，直接调用 getName 函数。既然是直接调用，那么就是访问当前上下文作用域内的叫 getName 的函数，所有主要看 4 和 5。<br>这里有个坑，一是变量声明提升，二是函数表达式和函数声明的区别。</p>
<p>相关文档可参考 <a href="/2020/03/30/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="关于JavaScript的函数声明和函数表达式">关于JavaScript的函数声明和函数表达式</a> 和 <a href="/2020/03/30/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/" title="关于JavaScript的变量提升">关于JavaScript的变量提升</a></p>
<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明</span><br><span class="line">function test() &#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数表达式</span><br><span class="line">var test &#x3D; function () &#123;</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看下面这个经典问题，在一个程序里面同时用函数声明和函数表达式定义一个名为 getName 的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getName(); &#x2F;&#x2F; hehe</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;haha&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;hehe&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha</span><br></pre></td></tr></table></figure>

<p>上面的代码看起来很类似，但实际上，JavaScript 函数上的一个“缺陷”就体现在 JavaScript 两种类型的函数定义上。</p>
<ul>
<li><strong>JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候卸载最后面，也还是会被提升至最前面</strong></li>
<li><strong>而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才调用</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName; &#x2F;&#x2F; 变量被提升，此时为 undefined</span><br><span class="line"></span><br><span class="line">getName(); &#x2F;&#x2F; hehe 函数被提升  这里受函数声明的影响，虽然函数声明在最后，但是被提升到最前面来了</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;haha&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha  函数表达式此时才被赋值并覆盖函数声明的定义</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;hehe&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha  这里就执行了函数表达式的值</span><br></pre></td></tr></table></figure>

<p>所以可以分解为这两个简单的问题来看清楚区别的本质</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName;</span><br><span class="line">console.log(getName); &#x2F;&#x2F; undefined</span><br><span class="line">getName(); &#x2F;&#x2F; Uncaught TypeError: getName is not a function</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;haha&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName;</span><br><span class="line">console.log(getName); &#x2F;&#x2F; function getName() &#123; console.log(&#39;hehe&#39;); &#125;</span><br><span class="line">getName(); &#x2F;&#x2F; hehe</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;hehe&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且“致命”的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机（解析时/运行时）上的差异。<br>当然我们给一个总结：JavaScript 中<strong>函数声明</strong>和<strong>函数表达式</strong>是存在区别的，<strong>函数声明</strong>在 JavaScript 解析时，进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而<strong>函数表达式</strong>的值是在 JavaScript 运行时确定，并且在表达式赋值完成后，该函数才能调用。</p>
<p>所以第二问 <code>getName();</code> 答案为 4，5 的函数声明被 4 的函数表达式覆盖了。</p>
<h4 id="Foo-getName-1"><a href="#Foo-getName-1" class="headerlink" title="Foo().getName();"></a>Foo().getName();</h4><p><code>Foo().getName();</code> 先执行了 Foo 函数，然后调用 Foo 函数的返回值（this）对象的 getName 属性函数。<br>Foo 函数的第一句 <code>getName = function() { alert(1); };</code> 是一句函数赋值语句，注意它没有 var 声明，所以先向当前 Foo 函数作用域中寻找 getName 变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有 getName 变量，找到了，也就是第二问 <code>var getName = function() { alert(4); };</code>，将此变量的值赋值为 <code>function() { alert(1); };</code>。<br>此处实际上是将外层作用域内的 getName 函数修改了。</p>
<blockquote>
<p>注意：此处若依然没有找到会一直向上查找到 window 对象，若 window 对象中也没有 getName 属性，就在 window 对象中创建一个 getName 变量并赋值 <code>function() { alert(1); };</code>。</p>
</blockquote>
<p>之后 Foo 函数的返回值是 this。this 的指向是由所在函数的调用方式决定的。而此处是直接调用方式，this 指向 window 对象，相当于执行 window.getName()，而 window 中的 getName 已经被修改为 <code>function() { alert(1); };</code>，所以最终输出 1。</p>
<p>此处考察了两个知识点，一个是<strong>变量作用域问题</strong>，一个是<strong>this 指向问题</strong>。我们利用下面的代码来回顾一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;haha&#39;; &#x2F;&#x2F; 全局变量</span><br><span class="line">window.name &#x3D; &#39;haha&#39;; &#x2F;&#x2F; 全局变量</span><br><span class="line">function getName() &#123;</span><br><span class="line">    name &#x3D; &#39;hehe&#39;; &#x2F;&#x2F; 没有用 var 声明，所以是全局变量，当前作用域没有 name</span><br><span class="line">    var privateName &#x3D; &#39;stacsw&#39;;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        console.log(this); &#x2F;&#x2F; window</span><br><span class="line">        return privateName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var getPrivate &#x3D; getName(&#39;Hello&#39;); &#x2F;&#x2F; 当前传参是局部变量，但函数中没有接受这个参数</span><br><span class="line">console.log(name); &#x2F;&#x2F; hehe</span><br><span class="line">console.log(getPrivate()); &#x2F;&#x2F; stacsw</span><br></pre></td></tr></table></figure>

<p>因为 JavaScript 没有块级作用域，但是函数是能产生一个作用域的，函数内部不同定义值的方法会直接或者间接影响到全局或者局部变量，函数内部的私有变量可以用闭包获取。<br>而关于 this，this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 最终指向的是那个调用它的对象。<br>所以第三问 <code>Foo().getName();</code> 中实际就是 window 在调用 Foo() 函数，所以 this 的指向就是 window。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.Foo().getName();</span><br><span class="line">&#x2F;&#x2F; -&gt; window.getName();</span><br></pre></td></tr></table></figure>

<h4 id="getName-1"><a href="#getName-1" class="headerlink" title="getName();"></a>getName();</h4><p>直接调用 getName 函数，相当于 window.getName()，因为这个变量已经被 Foo 函数执行时修改了，所以结果和第三问 <code>Foo().getName();</code> 相同，为 1。也就是说 Foo 执行后把全局的 getName 函数给重写了一次。</p>
<h4 id="new-Foo-getName"><a href="#new-Foo-getName" class="headerlink" title="new Foo.getName();"></a>new Foo.getName();</h4><p>第五问 <code>new Foo.getName();</code> 此处考察的是 JavaScript 的运算符优先级问题，这个还是挺难的，我当时看到这都懵了，没见过这么写的啊…<br>下面是 JavaScript 运算符的优先级表格，从高(20)到低(1)排列。可参见<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2U=" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN 运算符优先级<i class="fa fa-external-link"></i></span></p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算类型</th>
<th>关联性</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>20</td>
<td>圆括号</td>
<td>n/a(不相关)</td>
<td><code>( ... )</code></td>
</tr>
<tr>
<td>19</td>
<td>成员访问</td>
<td>从左到右</td>
<td><code>... . ...</code></td>
</tr>
<tr>
<td></td>
<td>需要计算的成员访问</td>
<td>从左到右</td>
<td><code>... [ ... ]</code></td>
</tr>
<tr>
<td></td>
<td>new(带参数列表)</td>
<td>n/a</td>
<td><code>new ... ( ... )</code></td>
</tr>
<tr>
<td></td>
<td>函数调用</td>
<td>从左到右</td>
<td><code>... ( ... )</code></td>
</tr>
<tr>
<td></td>
<td>可选链</td>
<td>从左到右</td>
<td><code>?.</code></td>
</tr>
<tr>
<td>18</td>
<td>new(无参数列表)</td>
<td>从右到左</td>
<td><code>new ...</code></td>
</tr>
<tr>
<td>17</td>
<td>后置递增(运算符在后)</td>
<td>n/a</td>
<td><code>... ++</code></td>
</tr>
<tr>
<td></td>
<td>后置递减(运算符在后)</td>
<td></td>
<td><code>... --</code></td>
</tr>
<tr>
<td>16</td>
<td>逻辑非</td>
<td>从右到左</td>
<td><code>! ...</code></td>
</tr>
<tr>
<td></td>
<td>按位非</td>
<td></td>
<td><code>~ ...</code></td>
</tr>
<tr>
<td></td>
<td>一元加法</td>
<td></td>
<td><code>+ ...</code></td>
</tr>
<tr>
<td></td>
<td>一元减法</td>
<td></td>
<td><code>- ...</code></td>
</tr>
<tr>
<td></td>
<td>前置递增</td>
<td></td>
<td><code>++ ...</code></td>
</tr>
<tr>
<td></td>
<td>前置递减</td>
<td></td>
<td><code>-- ...</code></td>
</tr>
<tr>
<td></td>
<td>typeof</td>
<td></td>
<td><code>typeof ...</code></td>
</tr>
<tr>
<td></td>
<td>void</td>
<td></td>
<td><code>void ...</code></td>
</tr>
<tr>
<td></td>
<td>delete</td>
<td></td>
<td><code>delete ...</code></td>
</tr>
<tr>
<td></td>
<td>await</td>
<td></td>
<td><code>await ...</code></td>
</tr>
<tr>
<td>15</td>
<td>幂</td>
<td>从右到左</td>
<td><code>... ** ...</code></td>
</tr>
<tr>
<td>14</td>
<td>乘法</td>
<td>从左到右</td>
<td><code>... * ...</code></td>
</tr>
<tr>
<td></td>
<td>除法</td>
<td></td>
<td><code>... / ...</code></td>
</tr>
<tr>
<td></td>
<td>取模</td>
<td></td>
<td><code>... % ...</code></td>
</tr>
<tr>
<td>13</td>
<td>加法</td>
<td>从左到右</td>
<td><code>... + ...</code></td>
</tr>
<tr>
<td></td>
<td>减法</td>
<td></td>
<td><code>... - ...</code></td>
</tr>
<tr>
<td>12</td>
<td>按位左移</td>
<td>从左到右</td>
<td><code>... &lt;&lt; ...</code></td>
</tr>
<tr>
<td></td>
<td>按位右移</td>
<td></td>
<td><code>... &gt;&gt; ...</code></td>
</tr>
<tr>
<td></td>
<td>无符号右移</td>
<td></td>
<td><code>... &gt;&gt;&gt; ...</code></td>
</tr>
<tr>
<td>11</td>
<td>小于</td>
<td>从左到右</td>
<td><code>... &lt; ...</code></td>
</tr>
<tr>
<td></td>
<td>小于等于</td>
<td></td>
<td><code>... &lt;= ...</code></td>
</tr>
<tr>
<td></td>
<td>大于</td>
<td></td>
<td><code>... &gt; ...</code></td>
</tr>
<tr>
<td></td>
<td>大于等于</td>
<td></td>
<td><code>... &gt;= ...</code></td>
</tr>
<tr>
<td></td>
<td>in</td>
<td></td>
<td><code>... in ...</code></td>
</tr>
<tr>
<td></td>
<td>instanceof</td>
<td></td>
<td><code>... instanceof ...</code></td>
</tr>
<tr>
<td>10</td>
<td>等号</td>
<td>从左到右</td>
<td><code>... == ...</code></td>
</tr>
<tr>
<td></td>
<td>非等号</td>
<td></td>
<td><code>... != ...</code></td>
</tr>
<tr>
<td></td>
<td>全等号</td>
<td></td>
<td><code>... === ...</code></td>
</tr>
<tr>
<td></td>
<td>非全等号</td>
<td></td>
<td><code>... !== ...</code></td>
</tr>
<tr>
<td>9</td>
<td>按位与</td>
<td>从左到右</td>
<td><code>... &amp; ...</code></td>
</tr>
<tr>
<td>8</td>
<td>按位异或</td>
<td>从左到右</td>
<td><code>... ^ ...</code></td>
</tr>
<tr>
<td>7</td>
<td>按位或</td>
<td>从左到右</td>
<td><code>... | ...</code></td>
</tr>
<tr>
<td>6</td>
<td>逻辑与</td>
<td>从左到右</td>
<td><code>... &amp;&amp; ...</code></td>
</tr>
<tr>
<td>5</td>
<td>逻辑或</td>
<td>从左到右</td>
<td><code>... || ...</code></td>
</tr>
<tr>
<td>4</td>
<td>条件运算符</td>
<td>从右到左</td>
<td><code>... ? ... : ...</code></td>
</tr>
<tr>
<td>3</td>
<td>赋值</td>
<td>从右到左</td>
<td><code>... = ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... += ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... -= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... *= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... /= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... %= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... &lt;&lt;= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... &gt;&gt;= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... &gt;&gt;&gt;= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... &amp;= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... ^= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... |= ...</code></td>
</tr>
<tr>
<td>2</td>
<td>yield</td>
<td>从右到左</td>
<td><code>yield ...</code></td>
</tr>
<tr>
<td></td>
<td>yield*</td>
<td></td>
<td><code>yield* ...</code></td>
</tr>
<tr>
<td>1</td>
<td>展开运算符</td>
<td>n/a</td>
<td><code>...</code> …</td>
</tr>
<tr>
<td>0</td>
<td>逗号</td>
<td>从左到右</td>
<td><code>... , ...</code></td>
</tr>
</tbody></table>
<p>从上面优先级表中第 19 和第 18 中可以看出关于 new 的优先级，<code>.成员访问</code> 和 <code>new(带参数列表)</code> 和 <code>函数调用</code> 同级，比 <code>new(无参数列表)</code> 高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Foo.getName();</span><br><span class="line">&#x2F;&#x2F; -&gt; new (Foo.getName)();</span><br></pre></td></tr></table></figure>

<ul>
<li>点的优先级(19)比 <code>new(无参数列表)</code> (18) 优先级高</li>
<li>当点运算完后又因为有个括号 <code>()</code>，此时就是变成 <code>new有参数列表</code> (19)，所以直接执行 <code>new</code>，当然也可能有朋友会有疑问为什么遇到 <code>()</code> 不函数调用再 <code>new</code> 呢，那是因为 <code>函数调用</code> (18)比 <code>new有参数列表</code> (19)优先级低。</li>
</ul>
<blockquote>
<p><code>.成员访问</code>(19) &gt; <code>函数调用</code>(19) &gt; <code>new(无参数列表)</code>(18)</p>
</blockquote>
<p>综上所述，第五问 <code>new Foo.getName();</code> 答案为 2。</p>
<h4 id="new-Foo-getName-1"><a href="#new-Foo-getName-1" class="headerlink" title="new Foo().getName();"></a>new Foo().getName();</h4><p>第六问 <code>new Foo().getName();</code>，比第五问 <code>new Foo.getName();</code> 出多了一个 <code>()</code>，优先级也就发生了变化</p>
<blockquote>
<p>new Foo().getName();<br>// -&gt; (new Foo()).getName();</p>
</blockquote>
<p>根据优先级表，首先是 <code>new(有参数列表)</code>(19)跟 <code>点</code> 和 <code>函数调用</code> 的优先级是同级，同级按照从左向右的执行顺序，所以先执行 <code>new(有参数列表)</code>(19)再执行 <code>点</code> 的优先级(19)，最后再 <code>函数调用</code> (19)。</p>
<blockquote>
<p><code>new(有参数列表)</code>(19) &gt; <code>.成员访问</code>(19) &gt; <code>函数调用</code>(19)</p>
</blockquote>
<p>这里还有个小知识点，Foo 作为构造函数有返回值，这里说下 JavaScript 中构造函数返回值的问题。</p>
<h5 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h5><p>在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。<br>而在 JavaScript 中的构造函数可以有返回值也可以没有。</p>
<ol>
<li>没有返回值则按照其他语言一样返回实例化对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Foo(&#39;haha&#39;));</span><br></pre></td></tr></table></figure>

<p><img data-src="https://pic.downk.cc/item/5e832ef7504f4bcb0433479c.png" alt=""></p>
<ol start="2">
<li>若有返回值，则检查其返回值是否为引用类型。如果是非引用类型，如基本类型(String, Number, Boolean, Undefined, Null, Symbol)则与无返回值相同，返回其实例化对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    return 200;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Foo(&#39;haha&#39;));</span><br></pre></td></tr></table></figure>

<p><img data-src="https://pic.downk.cc/item/5e832ff1504f4bcb043409d6.png" alt=""></p>
<ol start="3">
<li>若返回值是引用类型，则返回这个引用类型。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    return &#123;</span><br><span class="line">        age: 16</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Foo(&#39;haha&#39;));</span><br></pre></td></tr></table></figure>

<p><img data-src="https://pic.downk.cc/item/5e83305f504f4bcb04346114.png" alt=""></p>
<p>原题中，由于返回的是 this，而 this 在构造函数中本来就代表当前实例化对象，所以 Foo 函数返回实例化对象。<br>之后调用实例化对象的 getName 函数，因为在 Foo 构造函数中没有为实例化对象添加任何属性，所以在当前对象的原型对象中寻找 getName 函数。<br>当然这里再拓展个题外话，如果构造函数和原型链都有相同的方法，如下面的代码，那么默认拿构造函数的公有方法而不是原型链上的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.getName &#x3D; function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.name &#x3D; &#39;hehe&#39;;</span><br><span class="line">Foo.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    return &#39;hehe&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log((new Foo(&#39;haha&#39;)).name); &#x2F;&#x2F; haha</span><br><span class="line">console.log((new Foo(&#39;haha&#39;)).getName()); &#x2F;&#x2F; haha</span><br></pre></td></tr></table></figure>

<h4 id="new-new-Foo-getName"><a href="#new-new-Foo-getName" class="headerlink" title="new new Foo().getName();"></a>new new Foo().getName();</h4><p>第七问 <code>new new Foo().getName();</code> 同样是运算符优先级问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new new Foo().getName();</span><br><span class="line">&#x2F;&#x2F; -&gt; new ((new Foo()).getName)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>new(有参数列表)</code>(19) &gt; <code>.成员访问</code>(19) &gt; <code>new(有参数列表)</code>(19)</p>
</blockquote>
<p>先初始化 Foo 的实例化对象，然后将其原型上的 getName 函数作为构造函数再次 new，所以最终结果为 3。</p>
<h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName &#x3D; function () &#123; alert (1); &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function () &#123; alert (2);&#125;;</span><br><span class="line">Foo.prototype.getName &#x3D; function () &#123; alert (3);&#125;;</span><br><span class="line">var getName &#x3D; function () &#123; alert (4);&#125;;</span><br><span class="line">function getName() &#123; alert (5);&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;答案：</span><br><span class="line">Foo.getName(); &#x2F;&#x2F; 2</span><br><span class="line">getName(); &#x2F;&#x2F; 4</span><br><span class="line">Foo().getName(); &#x2F;&#x2F; 1</span><br><span class="line">getName(); &#x2F;&#x2F; 1</span><br><span class="line">new Foo.getName(); &#x2F;&#x2F; 2</span><br><span class="line">new Foo().getName(); &#x2F;&#x2F; 3</span><br><span class="line">new new Foo().getName(); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>增加一下难度，在 Foo 函数里面多加一个公有方法 getName。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    this.getName &#x3D; function() &#123;</span><br><span class="line">        console.log(3);</span><br><span class="line">        return &#123;</span><br><span class="line">            getName: getName &#x2F;&#x2F;这个就是第六问中涉及的构造函数的返回值问题</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line">    &#x2F;&#x2F;这个就是第六问中涉及到的，JS构造函数公有方法和原型链方法的优先级</span><br><span class="line">    getName &#x3D; function() &#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">    &#125;;</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    console.log(6);</span><br><span class="line">&#125;;</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;;</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;答案：</span><br><span class="line">Foo.getName(); &#x2F;&#x2F; 2</span><br><span class="line">getName(); &#x2F;&#x2F; 4</span><br><span class="line">console.log(Foo()) &#x2F;&#x2F; window</span><br><span class="line">Foo().getName(); &#x2F;&#x2F; 1</span><br><span class="line">getName(); &#x2F;&#x2F; 1</span><br><span class="line">new Foo.getName(); &#x2F;&#x2F; 2</span><br><span class="line">new Foo().getName(); &#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F;多了一问</span><br><span class="line">new Foo().getName().getName(); &#x2F;&#x2F; 3 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dzY2F0cy9hcnRpY2xlcy9pc3N1ZXMvODU=" title="https://github.com/Wscats/articles/issues/85">https://github.com/Wscats/articles/issues/85<i class="fa fa-external-link"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>面试题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JavaScript的函数声明和函数表达式</title>
    <url>/2020/03/30/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>JavaScript定义函数有两种类型</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function wscat(type) &#123;</span><br><span class="line">    console.log(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var oaoafly &#x3D; function(type) &#123;</span><br><span class="line">    console.log(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看下面这个经典的问题，在一个程序里面同时用函数声明和函数表达式定义一个名为 getName 的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getName(); &#x2F;&#x2F; oaoafly</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;wscat&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; wscat</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;oaoafly&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; wscat</span><br></pre></td></tr></table></figure>

<p>上面的代码看起来很类似，感觉也什么太大差别。但实际上，JavaScript函数上的一个“陷阱”就体现在JavaScript两种类型的函数定义上。</p>
<ul>
<li>JavaScript解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候写在最后面，也还是会被提升至最前面。</li>
<li>用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName; &#x2F;&#x2F; 变量被提升，此时为undefined</span><br><span class="line">getName(); &#x2F;&#x2F; oaoafly 函数声明被提升</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;wscat&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; wscat 函数表达式此时才覆盖函数声明的定义</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;oaoafly&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; wscat 这里执行的是函数表达式</span><br></pre></td></tr></table></figure>

<p>所以可以分解为这两个简单的问题来看清楚区别的本质</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName;</span><br><span class="line">console.log(getName) &#x2F;&#x2F; undefined</span><br><span class="line">getName(); &#x2F;&#x2F; Uncaught TypeError: getName is not a function</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;wscat&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName;</span><br><span class="line">console.log(getName); &#x2F;&#x2F; function getName() &#123; console.log(&#39;oaoafly&#39;); &#125;</span><br><span class="line">getName(); &#x2F;&#x2F; oaoafly</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;oaoafly&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且“致命”的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机(解析时/运行时)上的差异。</p>
<p>总结：JavaScript中的函数声明和函数表达式是存在区别的，函数声明在JavaScript解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JavaScript运行时确定，并且在表达式赋值完成后，该函数才能调用。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JavaScript的变量提升</title>
    <url>/2020/03/30/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v &#x3D; &#39;hello world&#39;;</span><br><span class="line">alert(v);</span><br></pre></td></tr></table></figure>

<p>弹出 Hello World</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v &#x3D; &#39;hello world&#39;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    alert(v);</span><br><span class="line">    var v &#x3D; &#39;I love you&#39;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>也是弹出 hello world</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v &#x3D; &#39;hello world&#39;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    alert(v);</span><br><span class="line">    var v &#x3D; &#39;i love you&#39;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>弹出 undefined</p>
<p>这里隐藏了一个陷阱，就是JavaScript中的变量提升</p>
<p>它相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v &#x3D; &#39;hello world&#39;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var v;</span><br><span class="line">    alert(v);</span><br><span class="line">    v &#x3D; &#39;i love you&#39;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>变量提升，简单的理解，就是把变量提升到函数的最顶端的地方。需要说明的是，变量提升只是提升变量的声明，并不是把赋值也提升上来，没有赋值的变量初始值是undefined。所以上面就出现了声明undefined的var，因为赋值在后面，声明提升在了前面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        var x &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">    var y &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var x, y;</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        x &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">    y &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一点注意的是因为JavaScript是函数级作用域，只有函数才会创建新的作用域，而不像其他语言有块级作用域，例如块，就像if语句，在上面的例子中，不管会不会进入if代码块，函数声明都会提升到当前作用域的顶部，得到执行，在JavaScript中并不会创建一个新的作用域。<br>从这里我们应该体会到，当我们在写JavaScript code 的时候，我们需要把变量放到块级作用域的顶端，不然容易发生一些意想不到的错误。<br>注意：ES5只有全局作用域和函数作用域，没有块级作用域。</p>
<p>还有一种就是函数提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myTest() &#123;</span><br><span class="line">    foo();</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        alert(&#39;hello world&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br></pre></td></tr></table></figure>

<p>弹出 ‘hello world’ // 这里函数声明提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myTest() &#123;</span><br><span class="line">    foo();</span><br><span class="line">    var foo &#x3D; function() &#123;</span><br><span class="line">        alert(&#39;我不会被弹出&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br></pre></td></tr></table></figure>

<p>报错：foo不是函数<br>相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myTest() &#123;</span><br><span class="line">    var foo;</span><br><span class="line">    foo();</span><br><span class="line">    foo &#x3D; function() &#123;</span><br><span class="line">        alert(&#39;我不会被弹出&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>动漫日记</title>
    <url>/2020/04/11/%E5%8A%A8%E6%BC%AB%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>身边没有喜欢动漫的通道人，每次分享都会被说：“小孩子看的东西”。所以才有了想要写此文章的目的，每看完一部都会更新，也是保持写博客的习惯。</p>
<p>我喜欢看爱情，校园番，以下有强烈推荐看的番剧，一定要看哦，甜甜爱情在这个物质生活、快节奏生活里给自己一点点努力下去的动力，吃饱饱的狗粮才能笑看身边的物质爱情，因为“爱情”从来都是甜的让人羡慕！ </p>
<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>直到 2020.04.11，我所观看的所有动漫</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HELLO WORLD</span><br><span class="line">ANOTHER WORLD</span><br><span class="line">擅长捉弄人的(原)高木同学（漫画）</span><br><span class="line">擅长捉弄的高木同学2</span><br><span class="line">好想告诉你2</span><br><span class="line">辉夜大小姐想让我告白</span><br><span class="line">政宗君的复仇</span><br><span class="line">恋爱四格小剧场(徒然喜欢你)</span><br><span class="line">温暖的印记</span><br><span class="line">月色真美</span><br><span class="line">天使的心跳</span><br><span class="line">末日时在做什么？有没有空？可以来拯救吗？</span><br><span class="line">我们仍未知道那天所看见的花的名字</span><br><span class="line">一周的朋友</span><br><span class="line">可塑性记忆</span><br><span class="line">境界的彼方</span><br><span class="line">高分少女2</span><br><span class="line">敦君与女朋友</span><br><span class="line">3D彼女2</span><br><span class="line">紫罗兰永恒花园</span><br><span class="line">紫罗兰永恒花园外传</span><br><span class="line">关于完全听不懂老公在说什么2</span><br><span class="line">DARLING in the FRANXX</span><br><span class="line">龙与虎</span><br><span class="line">路人女主的养成方法2</span><br><span class="line">一起一起这里那里</span><br><span class="line">玉子市场、玉子爱情故事</span><br><span class="line">Re:从零开始的异世界生活、Re:从零开始的异世界生活 新编集版、Re:从零开始的异世界生活 冰结之绊、Re:从零开始的异世界生活 Memory Snow</span><br><span class="line">青春猪头少年不会梦到兔女郎学姐、青春猪头少年不做怀梦少女的梦动漫&#x2F;剧场版		</span><br><span class="line"></span><br><span class="line">----楼上的动漫都是强烈推荐的----</span><br><span class="line"></span><br><span class="line">化物语、伪物语、猫物语(黑)、猫物语(白)、倾物语、囮物语、鬼物语</span><br><span class="line">线上游戏的老婆不可能是女生？</span><br><span class="line">寄宿学校的朱丽叶</span><br><span class="line">贤者之孙</span><br><span class="line">如果有妹妹就好了</span><br><span class="line">喜欢本大爷的竟然只有你一个?</span><br><span class="line">(overflow)欧巴来洗澡</span><br><span class="line">入间同学入魔了</span><br><span class="line">我的狐仙女友</span><br><span class="line">漆黑的子弹</span><br><span class="line">大家的河合庄</span><br><span class="line">妄想学生会2</span><br><span class="line">巧克力与香子兰</span><br><span class="line">我的脑内恋碍选项</span><br><span class="line">恋爱随意链接</span><br><span class="line">魔法禁书目录3</span><br><span class="line">平凡职业造就世界最强</span><br><span class="line">欢迎来到实力至上主义教室</span><br><span class="line">老妈平砍连击带顺劈</span><br><span class="line">为美好的世界献上祝福2</span><br><span class="line">就算是哥哥有爱就没问题了对吧</span><br><span class="line">我的青春恋爱物语果然有问题2</span><br><span class="line">ISLAND</span><br><span class="line">乃木坂春香的秘密2</span><br><span class="line">笨蛋测验召唤兽2</span><br><span class="line">只要长得可爱，即使是变态你也喜欢吗？</span><br><span class="line">重来吧、魔王大人！</span><br><span class="line">山田君与7个魔女</span><br><span class="line">时钟机关之星</span><br><span class="line">我老婆是学生会长2</span><br><span class="line">线上游戏的老婆不可能是女孩子</span><br><span class="line">无限斯特拉托斯</span><br><span class="line">爆肝工程师的异世界狂想曲</span><br><span class="line">关于我转生后成为史莱姆的那件事</span><br><span class="line">三坪房间的侵略者</span><br><span class="line">在地下城寻求邂逅是否搞错了什么2、在地下城寻求邂逅是否搞错了什么 剧场版 俄里翁之箭</span><br><span class="line">贤惠幼妻仙狐小姐</span><br><span class="line">盾之勇者成名录</span><br><span class="line">一个人的〇〇小日子</span><br><span class="line">游戏人生、游戏人生zero</span><br><span class="line">变态王子与不笑猫</span><br><span class="line">我女友与青梅竹马的惨烈修罗场</span><br><span class="line">我喜欢的妹妹但不是妹妹</span><br><span class="line">哥布林殺手</span><br><span class="line">学战都市2</span><br><span class="line">约会大作战3</span><br><span class="line">小桃小栗Love Love物语</span><br><span class="line">爱，死亡和机器人</span><br><span class="line">天使降临到了我身边</span><br><span class="line">品酒要在夫妻后</span><br><span class="line">狗与剪刀的正确用法</span><br><span class="line">公主恋人(不推荐)</span><br></pre></td></tr></table></figure>

<h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>上述动漫中，有一些后宫番，18禁番，如果你不小心看到了，请自行切换，这里只是记录，而非传播，不要找我要链接，一个字，没有！</p>
]]></content>
      <tags>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title>原生JavaScript实现拖放效果</title>
    <url>/2020/04/07/%E5%8E%9F%E7%94%9FJavaScript%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%94%BE%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>一个简单的拖放效果</p>
<p><img data-src="https://pic.downk.cc/item/5e8c8667504f4bcb043ffa0c.png" alt=""></p>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="HTML-很简单"><a href="#HTML-很简单" class="headerlink" title="HTML 很简单"></a>HTML 很简单</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;droppable&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;draggable&quot; draggable&#x3D;&quot;true&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;droppable&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;droppable&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;droppable&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;droppable&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>class 为 droppable 是用于放置被拖动的元素, class 为 draggable 是可被拖动的元素. draggable 属性用于标识元素是否允许使用 拖放操作 API 拖动. true 表示元素可以被拖动. 详情查看 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy9kcmFnZ2FibGU=" title="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/draggable">MDN<i class="fa fa-external-link"></i></span></p>
</blockquote>
<h5 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: rgb(179, 6, 6);</span><br><span class="line">&#125;</span><br><span class="line">.draggable &#123;</span><br><span class="line">    background-image: url(&#39;http:&#x2F;&#x2F;source.unsplash.com&#x2F;random&#x2F;150x150&#39;);</span><br><span class="line">    position: relative;</span><br><span class="line">    height: 150px;</span><br><span class="line">    width: 150px;</span><br><span class="line">    top: 5px;</span><br><span class="line">    left: 5px;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.droppable &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    height: 160px;</span><br><span class="line">    width: 160px;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    border: 3px solid rgb(179, 6, 6);</span><br><span class="line">    background-color: white;</span><br><span class="line">&#125;</span><br><span class="line">.dragging &#123;</span><br><span class="line">    border: 4px solid white</span><br><span class="line">&#125;</span><br><span class="line">.drag-over &#123;</span><br><span class="line">    background-color: #f4f4f4;</span><br><span class="line">    border-style: dashed;</span><br><span class="line">&#125;</span><br><span class="line">.invisible &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>被拖动元素使用 <code>http://source.unsplash.com/random/150x150</code> 随机生成图片, dragging 为被拖动元素的边框样式, drag-over 为被拖动元素要放置但还没放下时的样式.</p>
</blockquote>
<h5 id="js-实现"><a href="#js-实现" class="headerlink" title="js 实现"></a>js 实现</h5><p>通过监听 draggable 和 droppable 的相关事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取被拖动元素</span><br><span class="line">const draggable &#x3D; document.querySelector(&#39;.draggable&#39;);</span><br><span class="line">&#x2F;&#x2F; 获取接收拖动元素[数组]</span><br><span class="line">const droppables &#x3D; document.querySelectorAll(&#39;.droppable&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听 draggable 的相关事件</span><br><span class="line">draggable.addEventListener(&#39;dragstart&#39;, dragStart);</span><br><span class="line">draggable.addEventListener(&#39;dragend&#39;, dragEnd);</span><br><span class="line"></span><br><span class="line">function dragStart() &#123;</span><br><span class="line">    this.className +&#x3D; &#39; dragging&#39;;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        this.className &#x3D; &#39;invisible&#39;;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dragEnd() &#123;</span><br><span class="line">    this.className &#x3D; &#39;draggable&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听 droppable 的相关事件</span><br><span class="line">for (const droppable of droppables) &#123;</span><br><span class="line">    droppable.addEventListener(&#39;dragover&#39;, dragOver);</span><br><span class="line">    droppable.addEventListener(&#39;dragleave&#39;, dragLeave);</span><br><span class="line">    droppable.addEventListener(&#39;dragenter&#39;, dragEnter);</span><br><span class="line">    droppable.addEventListener(&#39;drop&#39;, dragDrop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dragOver(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dragLeave(e) &#123;</span><br><span class="line">    this.className &#x3D; &#39;droppable&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dragEnter(e) &#123;</span><br><span class="line">    this.className +&#x3D; &#39; drag-over&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dragDrop(e) &#123;</span><br><span class="line">    this.className &#x3D; &#39;droppable&#39;;</span><br><span class="line">    this.append(draggable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当 draggable 元素被拖动时, 原来容器中的 draggable 不会消失, 需要手动将其隐藏. 如果同步操作会立马处罚 dragend 事件, 导致无法进行拖动, 所以在 setTimeout 的回调中异步设置以确保拖动操作开始后, 再将其隐藏.</p>
</blockquote>
<blockquote>
<p>在 dragOver 中我们阻止了默认行为, 是因为当被拖动元素放到指定位置并松开鼠标时, 在这一时刻会先触发 dragover 事件然后再触发 drop 事件, 但在 dragover 中默认行为可能会阻止 drop 事件, 所以需要 e.preventDefault() 阻止默认行为.</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实现Promise</title>
    <url>/2020/03/30/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0Promise/</url>
    <content><![CDATA[<h4 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+ 规范"></a>Promise/A+ 规范</h4><p><span class="exturl" data-url="aHR0cDovL21hbGNvbG15dS5naXRodWIuaW8vbWFsbm90ZS8yMDE1LzA2LzEyL1Byb21pc2VzLUEtUGx1cy8=" title="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/">Promise/A+ 规范<i class="fa fa-external-link"></i></span></p>
<h4 id="Promise-声明"><a href="#Promise-声明" class="headerlink" title="Promise 声明"></a>Promise 声明</h4><p>首先，Promise 肯定是一个类，我们用 class 来声明。</p>
<ul>
<li>由于 <code>new Promise((resolve, reject) =&gt; {})</code>，所以传入一个参数(函数)，Promise/A+ 里叫他 executor (奇怪，我找了半天没找到…)，传入就行了。</li>
<li>executor 里面有两个参数，一个叫 resolve（成功），一个叫 reject（失败）。</li>
<li>由于 resolve 和 reject 可执行，所以都是函数，我们用 let 声明。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造器</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 成功</span><br><span class="line">        let resolve &#x3D; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line">        &#x2F;&#x2F; 失败</span><br><span class="line">        let reject &#x3D; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line">        &#x2F;&#x2F; 立即执行</span><br><span class="line">        executor(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决基本状态"><a href="#解决基本状态" class="headerlink" title="解决基本状态"></a>解决基本状态</h4><p>Promise/A+ 有规定：</p>
<ul>
<li>Promise 存在三个状态，pending，fulfilled，rejected</li>
<li>pending 为初始状态（state），并可以转化为 fulfiied 和 rejected</li>
<li>fulfilled 时，不可转为其他状态，且必须有一个不可改变的值(value)</li>
<li>rejected 时，不可转为其他状态，且必须有一个不可改变的原因(reason)</li>
<li><code>new Promise((resolve, reject) =&gt;{ resolve(value); })</code> resolve 成功，接受参数 value，状态改为 fulfilled，不可再改变。</li>
<li><code>new Promise((resove, reject) =&gt; { reject(reason); })</code> reject 失败，接受参数 reason，状态改为 rejected，不可再改变。</li>
<li>若是 executor 函数报错，直接执行 reject();</li>
</ul>
<p>于是根据规定，我们获得一下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise&#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h4><p><strong>Promise/A+ 规定：Promise 有一个叫做 then 的方法，里面有两个参数：onFulfilled，onRejected，成功有成功的值，失败有失败的原因。</strong></p>
<ul>
<li>当状态 state 为 fulfilled，则执行 onFulfilled，传入 this.value。当状态 state 为 rejected，则执行 onRejected，传入 this.reason</li>
<li>如果 onFulfilled，onRejectred 是函数，则必须分别在 fulfilled，rejected 后被调用，value 或 reason 依次作为他们的第一个参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">            onFulfilled(this.value);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">            onRejected(this.reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决异步实现"><a href="#解决异步实现" class="headerlink" title="解决异步实现"></a>解决异步实现</h4><p><strong>现在基本可以实现简单的同步代码，但是当 resolve 在 setTimeout 内执行 then 时，state 还是 pending 状态。这时，我们就需要在 then 调用的时候，将成功和失败存到各自的数组，一旦 resolve 或 reject，就调用它们</strong></p>
<p>类似于发布订阅，先将 then 里面的两个函数储存起来，由于一个 Promise 可以有多个 then，所以存在同一个数组内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 多个 then 的情况</span><br><span class="line">let p &#x3D; new Promise();</span><br><span class="line">p.then();</span><br><span class="line">p.then();</span><br></pre></td></tr></table></figure>

<p>成功或失败时，forEach 调用它们</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 成功时存放的数组</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 失败时存放的数组</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F; 一旦 resolve 执行，调用成功数组的函数</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                &#x2F;&#x2F; 一旦 reject 执行，调用失败数组的函数</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">            onFulfilled(this.value);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">            onRejected(this.reason);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; state 为 pending 时</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">            this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                onFulfilled(this.value);</span><br><span class="line">            &#125;);</span><br><span class="line">            this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                onRejected(this.reason);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决链式调用"><a href="#解决链式调用" class="headerlink" title="解决链式调用"></a>解决链式调用</h4><p><strong>我们常常用到 <code>new Promise().then().then()</code>，这就是链式调用，用来解决回调地狱</strong><br>1、为了达成链式，我们默认在第一个 then 里面返回一个 Promise。Promise/A+ 规定了一个方法，就是在 then 里面返回一个新的 Promise，成为 promise2：<code>promise2 = new Promise((resolve, reject) =&gt; {})</code></p>
<ul>
<li>将这个 promise2 返回的值传递到下一个 then 中</li>
<li>如果返回一个普通的值，则将普通的值传递到下一个 then 中</li>
</ul>
<p>2、当我们在第一个 then 中 return 了一个参数(参数未知，需判断)。这个 return 出来的新的 promise 就是 onFulfilled() 或 onRejected() 的值</p>
<p>Promise/A+ 规定 onFulfilled() 或 onRejected() 的值，叫做 x，判断 x 的函数叫做 resolvePromise</p>
<ul>
<li>首先，要看 x 是不是 promise</li>
<li>如果时 promise，则取它的结果，作为新的 promise2 成功的结果</li>
<li>如果是普通值，直接作为 promise2 成功的结果</li>
<li>所以要比较 x 和 promise2 是不是相等</li>
<li>resolvePromise 的参数有 promise2，x，resolve，reject</li>
<li>resolve 和 reject 是 promise2 的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 成功时存放的数组</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 失败时存放的数组</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F; 一旦 resolve 执行，调用成功数组的函数</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                &#x2F;&#x2F; 一旦 reject 执行，调用失败数组的函数</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        let promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">                let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">                let x &#x3D; onRejected(this.reason);</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 pending 时</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;);</span><br><span class="line">                this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    let x &#x3D; onRejected(this.reason);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完成-resovlePromise-函数"><a href="#完成-resovlePromise-函数" class="headerlink" title="完成 resovlePromise 函数"></a>完成 resovlePromise 函数</h4><p>Promise/A+ 规定：</p>
<ol>
<li>如果 x 与 promise2 指向同一对象，会造成循环引用，自己等待自己完成，则以 <code>TypeError</code> 为据因拒绝执行 promise</li>
</ol>
<p>循环引用实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p &#x3D; new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    resolve(1);</span><br><span class="line">&#125;)</span><br><span class="line">let p2 &#x3D; p.then(resolve &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环引用，自己等待自己完成</span><br><span class="line">    return p2;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果 x 为Promise，则使用 promise 接受 x 的状态</p>
</li>
<li><p>否则，x 为对象或函数</p>
</li>
</ol>
<ul>
<li>x 不能是 null</li>
<li>x.then 赋值给 then</li>
<li>如果取 x.then 的值时抛出错误 e，则以 e 为据因拒绝 promise</li>
<li>如果 then 是一个函数，则用 call 执行 then</li>
<li>如果成功的回调还是 promise，就递归继续解析</li>
<li>x 是普通值，则直接 resolve(x)</li>
<li>成功和失败只能调用一个，所以设定一个 called 来防止多次调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环引用直接报错</span><br><span class="line">    if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;</span><br><span class="line">        return reject(new TypeError(&#39;Chaining cycle detected for promise&#39;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 防止多次调用</span><br><span class="line">    let called &#x3D; false;</span><br><span class="line">    if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            let then &#x3D; x.then;</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                then.call(x, y &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, r &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called &#x3D; true;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决其他问题"><a href="#解决其他问题" class="headerlink" title="解决其他问题"></a>解决其他问题</h4><p>Promise/A+ 规定 onFulfilled，onRejected 都是函数，如果不是，则直接被忽略。这里其实应该说如果不是则变为函数，成功时将 value 传递给下一个 then 中的 onFulfilled 中，失败时，直接抛出错误。</p>
<ul>
<li>onFulfilled 返回一个普通的值，直接等于 value =&gt; value</li>
<li>onRejected 返回一个普通的值，直接抛出错误 reason =&gt; throw reason</li>
<li>onFulfilled 或 onRejected 不能同步调用，所以使用 setTimeout 解决</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 成功时存放的数组</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 失败时存放的数组</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F; 一旦 resolve 执行，调用成功数组的函数</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                &#x2F;&#x2F; 一旦 reject 执行，调用失败数组的函数</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : value &#x3D;&gt; value;</span><br><span class="line">        onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : reason &#x3D;&gt; &#123; throw reason &#125;;</span><br><span class="line">        let promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onRejected(this.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 pending 时</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch(e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">                this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x &#x3D; onRejected(this.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch(e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便实现 catch、resolve、reject、race、all方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 成功时存放的数组</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 失败时存放的数组</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F; 一旦 resolve 执行，调用成功数组的函数</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                &#x2F;&#x2F; 一旦 reject 执行，调用失败数组的函数</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : value &#x3D;&gt; value;</span><br><span class="line">        onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : reason &#x3D;&gt; &#123; throw reason &#125;;</span><br><span class="line">        let promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onRejected(this.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 pending 时</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch(e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">                this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x &#x3D; onRejected(this.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch(e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise2;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现 catch 方法</span><br><span class="line">    catch(fn) &#123;</span><br><span class="line">        return this.then(null, fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环引用直接报错</span><br><span class="line">    if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;</span><br><span class="line">        return reject(new TypeError(&#39;Chaining cycle detected for promise&#39;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 防止多次调用</span><br><span class="line">    let called &#x3D; false;</span><br><span class="line">    if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            let then &#x3D; x.then;</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                then.call(x, y &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, r &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called &#x3D; true;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现 resolve 方法</span><br><span class="line">Promise.resolve &#x3D; function(val) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        resolve(val);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现 reject 方法</span><br><span class="line">Promise.reject &#x3D; function(reason) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现 race 方法</span><br><span class="line">Promise.race &#x3D; function(promises) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现 all 方法(获取所有的 promise，都执行 then，把结果放到数组，一起返回)</span><br><span class="line">Promise.all &#x3D; function(promises) &#123;</span><br><span class="line">    let arr &#x3D; [];</span><br><span class="line">    let i &#x3D; 0;</span><br><span class="line">    function processData(index, data) &#123;</span><br><span class="line">        arr[index] &#x3D; data;</span><br><span class="line">        i++;</span><br><span class="line">        if (i &#x3D;&#x3D;&#x3D; promise.length) &#123;</span><br><span class="line">            resolve(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(data &#x3D;&gt; &#123;</span><br><span class="line">                processData(i, data);</span><br><span class="line">            &#125;, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证我们的-Promise-是否正确"><a href="#验证我们的-Promise-是否正确" class="headerlink" title="验证我们的 Promise 是否正确"></a>验证我们的 Promise 是否正确</h4><ul>
<li><p>安装 <code>npm install -g promises-aplus-tests</code></p>
</li>
<li><p>命令行 <code>promises-aplus-test [js文件名].js</code></p>
</li>
<li><p>添加如下代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.defer &#x3D; Promise.deferred &#x3D; function () &#123;</span><br><span class="line">  let dfd &#x3D; &#123;&#125;</span><br><span class="line">  dfd.promise &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    dfd.resolve &#x3D; resolve;</span><br><span class="line">    dfd.reject &#x3D; reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  return dfd;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; Promise;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
</search>
