<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cookie 和 SameSite 属性</title>
    <url>/2020/04/02/Cookie-%E5%92%8C-SameSite-%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>一般我们都会说“HTTP 是一个无状态的协议”，不过要注意这里的 HTTP 其实是指 HTTP 1.x，而所谓无状态协议，简单的理解就是即使同一个客户端连续两次发送请求给服务器，服务器也识别不出这是同一个客户端发送的请求，这导致的问题就比如你加入了一个商品到购物车中，但是因为识别不出时同一个客户端，刷新一下页面就没有了…</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>为了解决 HTTP 无状态导致的问题，后来出现了 Cookie。不过这样说可能会让你产生一些误解，首先无状态并不是不好，有优点，但也会导致一些问题。而 Cookie 的存在也不是为了解决通讯协议无状态的问题，只是为了解决客户端与服务器会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。</p>
<h4 id="Cookie-介绍"><a href="#Cookie-介绍" class="headerlink" title="Cookie 介绍"></a>Cookie 介绍</h4><p>引用维基百科：</p>
<blockquote>
<p>Cookie (复数形式 Cookies)，类型为[小型文本文件]，只某些网站为了辨别用户身份而储存在用户本地终端上的数据。</p>
</blockquote>
<p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称(Name)，一个值(Value)和其他几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成，这些涉及的属性后面会介绍。</p>
<h4 id="Cookie-的查看"><a href="#Cookie-的查看" class="headerlink" title="Cookie 的查看"></a>Cookie 的查看</h4><p>我们可以在浏览器的开发者工具中查看到当前页面的 Cookie：</p>
<p><img data-src="https://pic.downk.cc/item/5e85893f504f4bcb04d14eda.png" alt=""></p>
<p>尽管我们在浏览器里查看到了 Cookie，这并不意味着 Cookie 文件只是存放在浏览器里的。实际上，Cookie 相关的内容还可以存到本地文件里，就比如说 Mac 下的 Chrome，存放目录就是 <code>~/Library/Application Support/Google/Chrome/Default</code>，里面会有一个名为 Cookie 的数据库文件，你可以使用 sqlite 软件打开它。存放在本地的好处就在于即使你关闭了浏览器，Cookie 依然可以生效。</p>
<h4 id="Cookie-的设置"><a href="#Cookie-的设置" class="headerlink" title="Cookie 的设置"></a>Cookie 的设置</h4><p>那 Cookie 是怎么设置的呢？简单来说就是：</p>
<ol>
<li>客户端发送 HTTP 请求到服务器</li>
<li>当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段</li>
<li>浏览器收到响应后保存下来 Cookie</li>
<li>之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器</li>
</ol>
<p>以 <code>https://main.m.taobao.com/</code> 为例</p>
<p>请求返回的 Response Header 可以看到 Set-Cookie 字段</p>
<p><img data-src="https://pic.downk.cc/item/5e85aac3504f4bcb04eb5ba1.png" alt=""></p>
<p>再查看 Cookie</p>
<p><img data-src="https://pic.downk.cc/item/5e85ab4d504f4bcb04ebc3af.png" alt=""></p>
<p>可以在 Request Header 中看到 Cookie 字段</p>
<p><img data-src="https://pic.downk.cc/item/5e85abe5504f4bcb04ec369c.png" alt=""></p>
<h4 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h4><p>从下面这张图中，可以看到 Cookie 相关的一些属性</p>
<p><img data-src="https://pic.downk.cc/item/5e85ae03504f4bcb04edd13e.png" alt=""></p>
<p>需要注意的点：</p>
<h6 id="Name-Value"><a href="#Name-Value" class="headerlink" title="Name/Value"></a>Name/Value</h6><p>用于 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。</p>
<h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>Expires 用于设置 Cookie 的过期时间。</p>
<p><code>Set-Cookie: id=a3etds; Expires=Thu, 16 Apr 2020 06:21:20 GMT;</code></p>
<p>当缺少 Expires 属性时，表示是会话性 Cookie 如上图 Expires 的值为 Session，表示的就是会话性 Cookie，当为会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下，即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。</p>
<p>与会话性 Cookie 相对应的是持久性 Cookie，持久性 Cookie 会保存在用户的硬盘中，直到过期或者清除 Cookie。这里值得注意的是，设定的日期和时间只与客户端相关，而不是服务器。</p>
<h6 id="Max-Age"><a href="#Max-Age" class="headerlink" title="Max-Age"></a>Max-Age</h6><p>Max-Age 用于设置在 Cookie 失效之前需要经过的秒数。</p>
<p><code>Set-Cookie: id=a3etds; Max-Age=604800;</code></p>
<p>Max-Age 可以是正数、负数甚至是 0.<br>如果 Max-Age 属性为正数，浏览器会将其持久化，即写到对应的 Cookie 文件中。<br>如果 Max-Age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。<br>如果 Max-Age 属性为 0，则会立即删除这个 Cookie。</p>
<p>假如 Expires 和 Max-Age 都存在，则 Max-Age 优先级更高。</p>
<h6 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h6><p>Domain 指定了 Cookie 可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分(但是不包含子域名);</p>
<p>像淘宝首页设置的 Domain 就是 .taobao.com，这样无论是 a.taobao.com 还是 b.taobao.com 都可以使用 Cookie。</p>
<p>需要注意的是，不能跨域设置 Cookie。</p>
<h6 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h6><p>Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。比如设置 <code>Path=/a</code>, <code>/a/b</code> 下的资源会带 Cookie 首部，<code>/c</code>则不会携带 Cookie 首部。</p>
<p>Domain 和 Path 标志共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
<h6 id="Secure-属性"><a href="#Secure-属性" class="headerlink" title="Secure 属性"></a>Secure 属性</h6><p>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。</p>
<h6 id="HTTPOnly"><a href="#HTTPOnly" class="headerlink" title="HTTPOnly"></a>HTTPOnly</h6><p>设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。</p>
<h6 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h6><p>SameSite 是最近非常值得一提的内容，因为 2 月份发布的 Chrome 80 版本中默认屏蔽了第三方的 Cookie。</p>
<h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><p>SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击。</p>
<h5 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h5><p>SameSite 可以有下面三种值：</p>
<ul>
<li><p><strong>Strict</strong> 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致</p>
</li>
<li><p><strong>Lax</strong> 允许部分第三方请求携带 Cookie</p>
</li>
<li><p><strong>None</strong> 无论是否跨站都会发送 Cookie</p>
</li>
</ul>
<p>之前默认是 None，Chrome 80 后默认为 Lax。</p>
<h6 id="跨域和跨站"><a href="#跨域和跨站" class="headerlink" title="跨域和跨站"></a>跨域和跨站</h6><p>首先要理解的一点就是<strong>跨站</strong>和<strong>跨域</strong>是不同的。[同站(same-site)/跨站(cross-site)] 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83ZTdkNDFjZDJiYWM=" title="https://www.jianshu.com/p/7e7d41cd2bac">第一方(first-party)/第三方(third-party)<i class="fa fa-external-link"></i></span>是等价的。但是与浏览器同源策略(SOP)中的[同源(same-origin)/跨域(cross-origin)]是完全不同的概念。</p>
<p>同源策略的同源是指两个 URL 的协议/域名/端口一致。例如，<span class="exturl" data-url="aHR0cHM6Ly93d3cudGFvYmEuY29tL3BhZ2VzLy4uLu+8jOWug+eahOWNj+iuruaYrw==" title="https://www.taoba.com/pages/...，它的协议是">https://www.taoba.com/pages/...，它的协议是<i class="fa fa-external-link"></i></span> <code>https</code>，域名是 <code>www.taobao.com</code>，端口是 <code>443</code>。</p>
<p>同源策略作为浏览器的安全基石，其[同源]判断是比较严格的，相对而言，Cookie 中的 [同站]判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表(Public Suffix List)中，例如，.com、.co.uk、.github.io 等。eTLD+1 则表示，有效顶级域名 + 二级域名，例如 <code>taobao.com</code>。</p>
<p>举几个例子，<code>www.taobao.com</code> 和 <code>www.baidu.com</code> 是跨站，<code>www.a.taobao.com</code> 和 <code>www.b.taobao.com</code> 是同站，<code>a.github.io</code> 和 <code>b.github.io</code> 是跨站(注意是跨站。有效顶级域名：.github.io，二级域名不同)</p>
<h6 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h6><p>接下来看下从 None 改成 Lax 到底影响了哪些地方的 Cookie 的发送?</p>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>实例</th>
<th>以前</th>
<th>Strict</th>
<th>Lax</th>
<th>None</th>
</tr>
</thead>
<tbody><tr>
<td>链接</td>
<td><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>发送 cookie</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>预加载</td>
<td><code>&lt;link ref=&quot;prerender&quot; href=&quot;...&quot; /&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>发送 cookie</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>get 表单</td>
<td><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>发送 cookie</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>post 表单</td>
<td><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>不发送</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>iframe</td>
<td><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>不发送</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>AJAX</td>
<td><code>$.get(&quot;...&quot;)</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>不发送</td>
<td>发送 cookie</td>
</tr>
<tr>
<td>Image</td>
<td><code>&lt;img src=&quot;...&quot;&gt;</code></td>
<td>发送 cookie</td>
<td>不发送</td>
<td>不发送</td>
<td>发送 cookie</td>
</tr>
</tbody></table>
<p>从上表可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站发送第三方 Cookie，改变成不发送。</p>
<p>Post 表单：应该的，学 CSRF 总会据表单的例子。</p>
<p>iframe：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响。</p>
<p>AJAX：可能会影响到部分前端取值的行为和结果。</p>
<p>Image：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受影响。</p>
<p>除了这些还有 script 的方式，这种方式也不会发送 Cookie，像淘宝的大部分请求都是 jsonp，如果涉及到跨站也有可能会被影响。</p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>解决方案就是设置 SameSite 为 none。</p>
<p>不过也有两点要注意的地方：</p>
<ul>
<li>HTTP 接口不支持 SameSite = none</li>
</ul>
<p>如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。</p>
<ul>
<li>需要 UA 监测，部分浏览器不能加 SameSite=none</li>
</ul>
<p>IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务器必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性。</p>
<h6 id="Cookie-的作用"><a href="#Cookie-的作用" class="headerlink" title="Cookie 的作用"></a>Cookie 的作用</h6><ol>
<li>会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)</li>
<li>个性化设置(如用户自定义设置、主题等)</li>
<li>浏览器行为跟踪(如跟踪分析用户行为等)</li>
</ol>
<h6 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h6><ol>
<li>储存空间很小(只有4KB - 10KB左右)</li>
<li>安全性不够高，可能被截取篡改</li>
<li>有些状态不可能保存在客户端，如为了防止重复提交表单，需要在服务器端保存一个计数器。如果计数器保存在客户端，那么就没有任何作用。</li>
</ol>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21xeXFpbmdmZW5nL0Jsb2cvaXNzdWVzLzE1Nw==" title="https://github.com/mqyqingfeng/Blog/issues/157">https://github.com/mqyqingfeng/Blog/issues/157<i class="fa fa-external-link"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JavaScript的变量提升</title>
    <url>/2020/03/30/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v &#x3D; &#39;hello world&#39;;</span><br><span class="line">alert(v);</span><br></pre></td></tr></table></figure>

<p>弹出 Hello World</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v &#x3D; &#39;hello world&#39;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    alert(v);</span><br><span class="line">    var v &#x3D; &#39;I love you&#39;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>也是弹出 hello world</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v &#x3D; &#39;hello world&#39;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    alert(v);</span><br><span class="line">    var v &#x3D; &#39;i love you&#39;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>弹出 undefined</p>
<p>这里隐藏了一个陷阱，就是JavaScript中的变量提升</p>
<p>它相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v &#x3D; &#39;hello world&#39;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var v;</span><br><span class="line">    alert(v);</span><br><span class="line">    v &#x3D; &#39;i love you&#39;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>变量提升，简单的理解，就是把变量提升到函数的最顶端的地方。需要说明的是，变量提升只是提升变量的声明，并不是把赋值也提升上来，没有赋值的变量初始值是undefined。所以上面就出现了声明undefined的var，因为赋值在后面，声明提升在了前面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        var x &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">    var y &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var x, y;</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        x &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">    y &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一点注意的是因为JavaScript是函数级作用域，只有函数才会创建新的作用域，而不像其他语言有块级作用域，例如块，就像if语句，在上面的例子中，不管会不会进入if代码块，函数声明都会提升到当前作用域的顶部，得到执行，在JavaScript中并不会创建一个新的作用域。<br>从这里我们应该体会到，当我们在写JavaScript code 的时候，我们需要把变量放到块级作用域的顶端，不然容易发生一些意想不到的错误。<br>注意：ES5只有全局作用域和函数作用域，没有块级作用域。</p>
<p>还有一种就是函数提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myTest() &#123;</span><br><span class="line">    foo();</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        alert(&#39;hello world&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br></pre></td></tr></table></figure>

<p>弹出 ‘hello world’ // 这里函数声明提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myTest() &#123;</span><br><span class="line">    foo();</span><br><span class="line">    var foo &#x3D; function() &#123;</span><br><span class="line">        alert(&#39;我不会被弹出&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br></pre></td></tr></table></figure>

<p>报错：foo不是函数<br>相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myTest() &#123;</span><br><span class="line">    var foo;</span><br><span class="line">    foo();</span><br><span class="line">    foo &#x3D; function() &#123;</span><br><span class="line">        alert(&#39;我不会被弹出&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTest();</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>关于JavaScript的函数声明和函数表达式</title>
    <url>/2020/03/30/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>JavaScript定义函数有两种类型</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function wscat(type) &#123;</span><br><span class="line">    console.log(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var oaoafly &#x3D; function(type) &#123;</span><br><span class="line">    console.log(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看下面这个经典的问题，在一个程序里面同时用函数声明和函数表达式定义一个名为 getName 的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getName(); &#x2F;&#x2F; oaoafly</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;wscat&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; wscat</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;oaoafly&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; wscat</span><br></pre></td></tr></table></figure>

<p>上面的代码看起来很类似，感觉也什么太大差别。但实际上，JavaScript函数上的一个“陷阱”就体现在JavaScript两种类型的函数定义上。</p>
<ul>
<li>JavaScript解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候写在最后面，也还是会被提升至最前面。</li>
<li>用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName; &#x2F;&#x2F; 变量被提升，此时为undefined</span><br><span class="line">getName(); &#x2F;&#x2F; oaoafly 函数声明被提升</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;wscat&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; wscat 函数表达式此时才覆盖函数声明的定义</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;oaoafly&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; wscat 这里执行的是函数表达式</span><br></pre></td></tr></table></figure>

<p>所以可以分解为这两个简单的问题来看清楚区别的本质</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName;</span><br><span class="line">console.log(getName) &#x2F;&#x2F; undefined</span><br><span class="line">getName(); &#x2F;&#x2F; Uncaught TypeError: getName is not a function</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;wscat&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName;</span><br><span class="line">console.log(getName); &#x2F;&#x2F; function getName() &#123; console.log(&#39;oaoafly&#39;); &#125;</span><br><span class="line">getName(); &#x2F;&#x2F; oaoafly</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;oaoafly&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且“致命”的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机(解析时/运行时)上的差异。</p>
<p>总结：JavaScript中的函数声明和函数表达式是存在区别的，函数声明在JavaScript解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JavaScript运行时确定，并且在表达式赋值完成后，该函数才能调用。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一道关于JavaScript综合面试题</title>
    <url>/2020/03/30/%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8EJavaScript%E7%BB%BC%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>以下是我之前确实面试过的一道题，当时答的很不好，事后也想不起来了，正好前两天看到一个公众号发出来了，把思路也给捋清楚了，就记录到这里了。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName &#x3D; function() &#123; alert(1); &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function() &#123; alert(2); &#125;</span><br><span class="line">Foo.prototype.getName &#x3D; function() &#123; alert(3); &#125;</span><br><span class="line">var getName &#x3D; function() &#123; alert(4); &#125;</span><br><span class="line">function getName() &#123; alert(5); &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请写出一下输出结果</span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line">new Foo.getName();</span><br><span class="line">new Foo().getName();</span><br><span class="line">new new Foo().getName();</span><br></pre></td></tr></table></figure>

<h4 id="Foo-getName"><a href="#Foo-getName" class="headerlink" title="Foo.getName();"></a>Foo.getName();</h4><p>让我们来分析下，<br>首先定义了一个 Foo 函数，<br>之后为 Foo 创建了一个叫 getName 的静态属性并赋值一个匿名函数，<br>之后为 Foo 的原型对象新创建了一个叫 getName 的匿名函数。<br>创建了一个名为 getName 函数表达式，<br>声明了一个 getName 函数。</p>
<p>第一问，Foo 函数也是对象，所以自然访问的就是函数上的静态属性，即<code>Foo.getName = function() { alert(2); }</code>;</p>
<p>以下例子用来加深理解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">    var name &#x3D; name; &#x2F;&#x2F; 私有属性</span><br><span class="line">    this.name &#x3D; name; &#x2F;&#x2F; 公开属性</span><br><span class="line">    function getName() &#123; &#x2F;&#x2F; 私有方法</span><br><span class="line">        alert(1);</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.getName &#x3D; function() &#123; &#x2F;&#x2F; 公有方法</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;</span><br><span class="line">User.name &#x3D; &#39;user&#39;; &#x2F;&#x2F; 静态属性</span><br><span class="line">User.getName &#x3D; function() &#123; &#x2F;&#x2F; 静态方法</span><br><span class="line">    alert(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getName"><a href="#getName" class="headerlink" title="getName();"></a>getName();</h4><p>第二问，直接调用 getName 函数。既然是直接调用，那么就是访问当前上下文作用域内的叫 getName 的函数，所有主要看 4 和 5。<br>这里有个坑，一是变量声明提升，二是函数表达式和函数声明的区别。</p>
<p>相关文档可参考 <a href="/2020/03/30/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="关于JavaScript的函数声明和函数表达式">关于JavaScript的函数声明和函数表达式</a> 和 <a href="/2020/03/30/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/" title="关于JavaScript的变量提升">关于JavaScript的变量提升</a></p>
<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明</span><br><span class="line">function test() &#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数表达式</span><br><span class="line">var test &#x3D; function () &#123;</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看下面这个经典问题，在一个程序里面同时用函数声明和函数表达式定义一个名为 getName 的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getName(); &#x2F;&#x2F; hehe</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;haha&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;hehe&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha</span><br></pre></td></tr></table></figure>

<p>上面的代码看起来很类似，但实际上，JavaScript 函数上的一个“缺陷”就体现在 JavaScript 两种类型的函数定义上。</p>
<ul>
<li><strong>JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候卸载最后面，也还是会被提升至最前面</strong></li>
<li><strong>而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才调用</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName; &#x2F;&#x2F; 变量被提升，此时为 undefined</span><br><span class="line"></span><br><span class="line">getName(); &#x2F;&#x2F; hehe 函数被提升  这里受函数声明的影响，虽然函数声明在最后，但是被提升到最前面来了</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;haha&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha  函数表达式此时才被赋值并覆盖函数声明的定义</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;hehe&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha  这里就执行了函数表达式的值</span><br></pre></td></tr></table></figure>

<p>所以可以分解为这两个简单的问题来看清楚区别的本质</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName;</span><br><span class="line">console.log(getName); &#x2F;&#x2F; undefined</span><br><span class="line">getName(); &#x2F;&#x2F; Uncaught TypeError: getName is not a function</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;haha&#39;);</span><br><span class="line">&#125;</span><br><span class="line">getName(); &#x2F;&#x2F; haha</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getName;</span><br><span class="line">console.log(getName); &#x2F;&#x2F; function getName() &#123; console.log(&#39;hehe&#39;); &#125;</span><br><span class="line">getName(); &#x2F;&#x2F; hehe</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(&#39;hehe&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且“致命”的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机（解析时/运行时）上的差异。<br>当然我们给一个总结：JavaScript 中<strong>函数声明</strong>和<strong>函数表达式</strong>是存在区别的，<strong>函数声明</strong>在 JavaScript 解析时，进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而<strong>函数表达式</strong>的值是在 JavaScript 运行时确定，并且在表达式赋值完成后，该函数才能调用。</p>
<p>所以第二问 <code>getName();</code> 答案为 4，5 的函数声明被 4 的函数表达式覆盖了。</p>
<h4 id="Foo-getName-1"><a href="#Foo-getName-1" class="headerlink" title="Foo().getName();"></a>Foo().getName();</h4><p><code>Foo().getName();</code> 先执行了 Foo 函数，然后调用 Foo 函数的返回值（this）对象的 getName 属性函数。<br>Foo 函数的第一句 <code>getName = function() { alert(1); };</code> 是一句函数赋值语句，注意它没有 var 声明，所以先向当前 Foo 函数作用域中寻找 getName 变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有 getName 变量，找到了，也就是第二问 <code>var getName = function() { alert(4); };</code>，将此变量的值赋值为 <code>function() { alert(1); };</code>。<br>此处实际上是将外层作用域内的 getName 函数修改了。</p>
<blockquote>
<p>注意：此处若依然没有找到会一直向上查找到 window 对象，若 window 对象中也没有 getName 属性，就在 window 对象中创建一个 getName 变量并赋值 <code>function() { alert(1); };</code>。</p>
</blockquote>
<p>之后 Foo 函数的返回值是 this。this 的指向是由所在函数的调用方式决定的。而此处是直接调用方式，this 指向 window 对象，相当于执行 window.getName()，而 window 中的 getName 已经被修改为 <code>function() { alert(1); };</code>，所以最终输出 1。</p>
<p>此处考察了两个知识点，一个是<strong>变量作用域问题</strong>，一个是<strong>this 指向问题</strong>。我们利用下面的代码来回顾一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;haha&#39;; &#x2F;&#x2F; 全局变量</span><br><span class="line">window.name &#x3D; &#39;haha&#39;; &#x2F;&#x2F; 全局变量</span><br><span class="line">function getName() &#123;</span><br><span class="line">    name &#x3D; &#39;hehe&#39;; &#x2F;&#x2F; 没有用 var 声明，所以是全局变量，当前作用域没有 name</span><br><span class="line">    var privateName &#x3D; &#39;stacsw&#39;;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        console.log(this); &#x2F;&#x2F; window</span><br><span class="line">        return privateName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var getPrivate &#x3D; getName(&#39;Hello&#39;); &#x2F;&#x2F; 当前传参是局部变量，但函数中没有接受这个参数</span><br><span class="line">console.log(name); &#x2F;&#x2F; hehe</span><br><span class="line">console.log(getPrivate()); &#x2F;&#x2F; stacsw</span><br></pre></td></tr></table></figure>

<p>因为 JavaScript 没有块级作用域，但是函数是能产生一个作用域的，函数内部不同定义值的方法会直接或者间接影响到全局或者局部变量，函数内部的私有变量可以用闭包获取。<br>而关于 this，this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 最终指向的是那个调用它的对象。<br>所以第三问 <code>Foo().getName();</code> 中实际就是 window 在调用 Foo() 函数，所以 this 的指向就是 window。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.Foo().getName();</span><br><span class="line">&#x2F;&#x2F; -&gt; window.getName();</span><br></pre></td></tr></table></figure>

<h4 id="getName-1"><a href="#getName-1" class="headerlink" title="getName();"></a>getName();</h4><p>直接调用 getName 函数，相当于 window.getName()，因为这个变量已经被 Foo 函数执行时修改了，所以结果和第三问 <code>Foo().getName();</code> 相同，为 1。也就是说 Foo 执行后把全局的 getName 函数给重写了一次。</p>
<h4 id="new-Foo-getName"><a href="#new-Foo-getName" class="headerlink" title="new Foo.getName();"></a>new Foo.getName();</h4><p>第五问 <code>new Foo.getName();</code> 此处考察的是 JavaScript 的运算符优先级问题，这个还是挺难的，我当时看到这都懵了，没见过这么写的啊…<br>下面是 JavaScript 运算符的优先级表格，从高(20)到低(1)排列。可参见<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2U=" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN 运算符优先级<i class="fa fa-external-link"></i></span></p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算类型</th>
<th>关联性</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>20</td>
<td>圆括号</td>
<td>n/a(不相关)</td>
<td><code>( ... )</code></td>
</tr>
<tr>
<td>19</td>
<td>成员访问</td>
<td>从左到右</td>
<td><code>... . ...</code></td>
</tr>
<tr>
<td></td>
<td>需要计算的成员访问</td>
<td>从左到右</td>
<td><code>... [ ... ]</code></td>
</tr>
<tr>
<td></td>
<td>new(带参数列表)</td>
<td>n/a</td>
<td><code>new ... ( ... )</code></td>
</tr>
<tr>
<td></td>
<td>函数调用</td>
<td>从左到右</td>
<td><code>... ( ... )</code></td>
</tr>
<tr>
<td></td>
<td>可选链</td>
<td>从左到右</td>
<td><code>?.</code></td>
</tr>
<tr>
<td>18</td>
<td>new(无参数列表)</td>
<td>从右到左</td>
<td><code>new ...</code></td>
</tr>
<tr>
<td>17</td>
<td>后置递增(运算符在后)</td>
<td>n/a</td>
<td><code>... ++</code></td>
</tr>
<tr>
<td></td>
<td>后置递减(运算符在后)</td>
<td></td>
<td><code>... --</code></td>
</tr>
<tr>
<td>16</td>
<td>逻辑非</td>
<td>从右到左</td>
<td><code>! ...</code></td>
</tr>
<tr>
<td></td>
<td>按位非</td>
<td></td>
<td><code>~ ...</code></td>
</tr>
<tr>
<td></td>
<td>一元加法</td>
<td></td>
<td><code>+ ...</code></td>
</tr>
<tr>
<td></td>
<td>一元减法</td>
<td></td>
<td><code>- ...</code></td>
</tr>
<tr>
<td></td>
<td>前置递增</td>
<td></td>
<td><code>++ ...</code></td>
</tr>
<tr>
<td></td>
<td>前置递减</td>
<td></td>
<td><code>-- ...</code></td>
</tr>
<tr>
<td></td>
<td>typeof</td>
<td></td>
<td><code>typeof ...</code></td>
</tr>
<tr>
<td></td>
<td>void</td>
<td></td>
<td><code>void ...</code></td>
</tr>
<tr>
<td></td>
<td>delete</td>
<td></td>
<td><code>delete ...</code></td>
</tr>
<tr>
<td></td>
<td>await</td>
<td></td>
<td><code>await ...</code></td>
</tr>
<tr>
<td>15</td>
<td>幂</td>
<td>从右到左</td>
<td><code>... ** ...</code></td>
</tr>
<tr>
<td>14</td>
<td>乘法</td>
<td>从左到右</td>
<td><code>... * ...</code></td>
</tr>
<tr>
<td></td>
<td>除法</td>
<td></td>
<td><code>... / ...</code></td>
</tr>
<tr>
<td></td>
<td>取模</td>
<td></td>
<td><code>... % ...</code></td>
</tr>
<tr>
<td>13</td>
<td>加法</td>
<td>从左到右</td>
<td><code>... + ...</code></td>
</tr>
<tr>
<td></td>
<td>减法</td>
<td></td>
<td><code>... - ...</code></td>
</tr>
<tr>
<td>12</td>
<td>按位左移</td>
<td>从左到右</td>
<td><code>... &lt;&lt; ...</code></td>
</tr>
<tr>
<td></td>
<td>按位右移</td>
<td></td>
<td><code>... &gt;&gt; ...</code></td>
</tr>
<tr>
<td></td>
<td>无符号右移</td>
<td></td>
<td><code>... &gt;&gt;&gt; ...</code></td>
</tr>
<tr>
<td>11</td>
<td>小于</td>
<td>从左到右</td>
<td><code>... &lt; ...</code></td>
</tr>
<tr>
<td></td>
<td>小于等于</td>
<td></td>
<td><code>... &lt;= ...</code></td>
</tr>
<tr>
<td></td>
<td>大于</td>
<td></td>
<td><code>... &gt; ...</code></td>
</tr>
<tr>
<td></td>
<td>大于等于</td>
<td></td>
<td><code>... &gt;= ...</code></td>
</tr>
<tr>
<td></td>
<td>in</td>
<td></td>
<td><code>... in ...</code></td>
</tr>
<tr>
<td></td>
<td>instanceof</td>
<td></td>
<td><code>... instanceof ...</code></td>
</tr>
<tr>
<td>10</td>
<td>等号</td>
<td>从左到右</td>
<td><code>... == ...</code></td>
</tr>
<tr>
<td></td>
<td>非等号</td>
<td></td>
<td><code>... != ...</code></td>
</tr>
<tr>
<td></td>
<td>全等号</td>
<td></td>
<td><code>... === ...</code></td>
</tr>
<tr>
<td></td>
<td>非全等号</td>
<td></td>
<td><code>... !== ...</code></td>
</tr>
<tr>
<td>9</td>
<td>按位与</td>
<td>从左到右</td>
<td><code>... &amp; ...</code></td>
</tr>
<tr>
<td>8</td>
<td>按位异或</td>
<td>从左到右</td>
<td><code>... ^ ...</code></td>
</tr>
<tr>
<td>7</td>
<td>按位或</td>
<td>从左到右</td>
<td><code>... | ...</code></td>
</tr>
<tr>
<td>6</td>
<td>逻辑与</td>
<td>从左到右</td>
<td><code>... &amp;&amp; ...</code></td>
</tr>
<tr>
<td>5</td>
<td>逻辑或</td>
<td>从左到右</td>
<td><code>... || ...</code></td>
</tr>
<tr>
<td>4</td>
<td>条件运算符</td>
<td>从右到左</td>
<td><code>... ? ... : ...</code></td>
</tr>
<tr>
<td>3</td>
<td>赋值</td>
<td>从右到左</td>
<td><code>... = ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... += ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... -= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... *= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... /= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... %= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... &lt;&lt;= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... &gt;&gt;= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... &gt;&gt;&gt;= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... &amp;= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... ^= ...</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>... |= ...</code></td>
</tr>
<tr>
<td>2</td>
<td>yield</td>
<td>从右到左</td>
<td><code>yield ...</code></td>
</tr>
<tr>
<td></td>
<td>yield*</td>
<td></td>
<td><code>yield* ...</code></td>
</tr>
<tr>
<td>1</td>
<td>展开运算符</td>
<td>n/a</td>
<td><code>...</code> …</td>
</tr>
<tr>
<td>0</td>
<td>逗号</td>
<td>从左到右</td>
<td><code>... , ...</code></td>
</tr>
</tbody></table>
<p>从上面优先级表中第 19 和第 18 中可以看出关于 new 的优先级，<code>.成员访问</code> 和 <code>new(带参数列表)</code> 和 <code>函数调用</code> 同级，比 <code>new(无参数列表)</code> 高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Foo.getName();</span><br><span class="line">&#x2F;&#x2F; -&gt; new (Foo.getName)();</span><br></pre></td></tr></table></figure>

<ul>
<li>点的优先级(19)比 <code>new(无参数列表)</code> (18) 优先级高</li>
<li>当点运算完后又因为有个括号 <code>()</code>，此时就是变成 <code>new有参数列表</code> (19)，所以直接执行 <code>new</code>，当然也可能有朋友会有疑问为什么遇到 <code>()</code> 不函数调用再 <code>new</code> 呢，那是因为 <code>函数调用</code> (18)比 <code>new有参数列表</code> (19)优先级低。</li>
</ul>
<blockquote>
<p><code>.成员访问</code>(19) &gt; <code>函数调用</code>(19) &gt; <code>new(无参数列表)</code>(18)</p>
</blockquote>
<p>综上所述，第五问 <code>new Foo.getName();</code> 答案为 2。</p>
<h4 id="new-Foo-getName-1"><a href="#new-Foo-getName-1" class="headerlink" title="new Foo().getName();"></a>new Foo().getName();</h4><p>第六问 <code>new Foo().getName();</code>，比第五问 <code>new Foo.getName();</code> 出多了一个 <code>()</code>，优先级也就发生了变化</p>
<blockquote>
<p>new Foo().getName();<br>// -&gt; (new Foo()).getName();</p>
</blockquote>
<p>根据优先级表，首先是 <code>new(有参数列表)</code>(19)跟 <code>点</code> 和 <code>函数调用</code> 的优先级是同级，同级按照从左向右的执行顺序，所以先执行 <code>new(有参数列表)</code>(19)再执行 <code>点</code> 的优先级(19)，最后再 <code>函数调用</code> (19)。</p>
<blockquote>
<p><code>new(有参数列表)</code>(19) &gt; <code>.成员访问</code>(19) &gt; <code>函数调用</code>(19)</p>
</blockquote>
<p>这里还有个小知识点，Foo 作为构造函数有返回值，这里说下 JavaScript 中构造函数返回值的问题。</p>
<h5 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h5><p>在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。<br>而在 JavaScript 中的构造函数可以有返回值也可以没有。</p>
<ol>
<li>没有返回值则按照其他语言一样返回实例化对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Foo(&#39;haha&#39;));</span><br></pre></td></tr></table></figure>

<p><img data-src="https://pic.downk.cc/item/5e832ef7504f4bcb0433479c.png" alt=""></p>
<ol start="2">
<li>若有返回值，则检查其返回值是否为引用类型。如果是非引用类型，如基本类型(String, Number, Boolean, Undefined, Null, Symbol)则与无返回值相同，返回其实例化对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    return 200;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Foo(&#39;haha&#39;));</span><br></pre></td></tr></table></figure>

<p><img data-src="https://pic.downk.cc/item/5e832ff1504f4bcb043409d6.png" alt=""></p>
<ol start="3">
<li>若返回值是引用类型，则返回这个引用类型。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    return &#123;</span><br><span class="line">        age: 16</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Foo(&#39;haha&#39;));</span><br></pre></td></tr></table></figure>

<p><img data-src="https://pic.downk.cc/item/5e83305f504f4bcb04346114.png" alt=""></p>
<p>原题中，由于返回的是 this，而 this 在构造函数中本来就代表当前实例化对象，所以 Foo 函数返回实例化对象。<br>之后调用实例化对象的 getName 函数，因为在 Foo 构造函数中没有为实例化对象添加任何属性，所以在当前对象的原型对象中寻找 getName 函数。<br>当然这里再拓展个题外话，如果构造函数和原型链都有相同的方法，如下面的代码，那么默认拿构造函数的公有方法而不是原型链上的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.getName &#x3D; function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.name &#x3D; &#39;hehe&#39;;</span><br><span class="line">Foo.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    return &#39;hehe&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log((new Foo(&#39;haha&#39;)).name); &#x2F;&#x2F; haha</span><br><span class="line">console.log((new Foo(&#39;haha&#39;)).getName()); &#x2F;&#x2F; haha</span><br></pre></td></tr></table></figure>

<h4 id="new-new-Foo-getName"><a href="#new-new-Foo-getName" class="headerlink" title="new new Foo().getName();"></a>new new Foo().getName();</h4><p>第七问 <code>new new Foo().getName();</code> 同样是运算符优先级问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new new Foo().getName();</span><br><span class="line">&#x2F;&#x2F; -&gt; new ((new Foo()).getName)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>new(有参数列表)</code>(19) &gt; <code>.成员访问</code>(19) &gt; <code>new(有参数列表)</code>(19)</p>
</blockquote>
<p>先初始化 Foo 的实例化对象，然后将其原型上的 getName 函数作为构造函数再次 new，所以最终结果为 3。</p>
<h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName &#x3D; function () &#123; alert (1); &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function () &#123; alert (2);&#125;;</span><br><span class="line">Foo.prototype.getName &#x3D; function () &#123; alert (3);&#125;;</span><br><span class="line">var getName &#x3D; function () &#123; alert (4);&#125;;</span><br><span class="line">function getName() &#123; alert (5);&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;答案：</span><br><span class="line">Foo.getName(); &#x2F;&#x2F; 2</span><br><span class="line">getName(); &#x2F;&#x2F; 4</span><br><span class="line">Foo().getName(); &#x2F;&#x2F; 1</span><br><span class="line">getName(); &#x2F;&#x2F; 1</span><br><span class="line">new Foo.getName(); &#x2F;&#x2F; 2</span><br><span class="line">new Foo().getName(); &#x2F;&#x2F; 3</span><br><span class="line">new new Foo().getName(); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>增加一下难度，在 Foo 函数里面多加一个公有方法 getName。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    this.getName &#x3D; function() &#123;</span><br><span class="line">        console.log(3);</span><br><span class="line">        return &#123;</span><br><span class="line">            getName: getName &#x2F;&#x2F;这个就是第六问中涉及的构造函数的返回值问题</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line">    &#x2F;&#x2F;这个就是第六问中涉及到的，JS构造函数公有方法和原型链方法的优先级</span><br><span class="line">    getName &#x3D; function() &#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">    &#125;;</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    console.log(6);</span><br><span class="line">&#125;;</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;;</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;答案：</span><br><span class="line">Foo.getName(); &#x2F;&#x2F; 2</span><br><span class="line">getName(); &#x2F;&#x2F; 4</span><br><span class="line">console.log(Foo()) &#x2F;&#x2F; window</span><br><span class="line">Foo().getName(); &#x2F;&#x2F; 1</span><br><span class="line">getName(); &#x2F;&#x2F; 1</span><br><span class="line">new Foo.getName(); &#x2F;&#x2F; 2</span><br><span class="line">new Foo().getName(); &#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F;多了一问</span><br><span class="line">new Foo().getName().getName(); &#x2F;&#x2F; 3 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dzY2F0cy9hcnRpY2xlcy9pc3N1ZXMvODU=" title="https://github.com/Wscats/articles/issues/85">https://github.com/Wscats/articles/issues/85<i class="fa fa-external-link"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>面试题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实现Promise</title>
    <url>/2020/03/30/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0Promise/</url>
    <content><![CDATA[<h4 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+ 规范"></a>Promise/A+ 规范</h4><p><span class="exturl" data-url="aHR0cDovL21hbGNvbG15dS5naXRodWIuaW8vbWFsbm90ZS8yMDE1LzA2LzEyL1Byb21pc2VzLUEtUGx1cy8=" title="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/">Promise/A+ 规范<i class="fa fa-external-link"></i></span></p>
<h4 id="Promise-声明"><a href="#Promise-声明" class="headerlink" title="Promise 声明"></a>Promise 声明</h4><p>首先，Promise 肯定是一个类，我们用 class 来声明。</p>
<ul>
<li>由于 <code>new Promise((resolve, reject) =&gt; {})</code>，所以传入一个参数(函数)，Promise/A+ 里叫他 executor (奇怪，我找了半天没找到…)，传入就行了。</li>
<li>executor 里面有两个参数，一个叫 resolve（成功），一个叫 reject（失败）。</li>
<li>由于 resolve 和 reject 可执行，所以都是函数，我们用 let 声明。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造器</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 成功</span><br><span class="line">        let resolve &#x3D; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line">        &#x2F;&#x2F; 失败</span><br><span class="line">        let reject &#x3D; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line">        &#x2F;&#x2F; 立即执行</span><br><span class="line">        executor(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决基本状态"><a href="#解决基本状态" class="headerlink" title="解决基本状态"></a>解决基本状态</h4><p>Promise/A+ 有规定：</p>
<ul>
<li>Promise 存在三个状态，pending，fulfilled，rejected</li>
<li>pending 为初始状态（state），并可以转化为 fulfiied 和 rejected</li>
<li>fulfilled 时，不可转为其他状态，且必须有一个不可改变的值(value)</li>
<li>rejected 时，不可转为其他状态，且必须有一个不可改变的原因(reason)</li>
<li><code>new Promise((resolve, reject) =&gt;{ resolve(value); })</code> resolve 成功，接受参数 value，状态改为 fulfilled，不可再改变。</li>
<li><code>new Promise((resove, reject) =&gt; { reject(reason); })</code> reject 失败，接受参数 reason，状态改为 rejected，不可再改变。</li>
<li>若是 executor 函数报错，直接执行 reject();</li>
</ul>
<p>于是根据规定，我们获得一下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise&#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h4><p><strong>Promise/A+ 规定：Promise 有一个叫做 then 的方法，里面有两个参数：onFulfilled，onRejected，成功有成功的值，失败有失败的原因。</strong></p>
<ul>
<li>当状态 state 为 fulfilled，则执行 onFulfilled，传入 this.value。当状态 state 为 rejected，则执行 onRejected，传入 this.reason</li>
<li>如果 onFulfilled，onRejectred 是函数，则必须分别在 fulfilled，rejected 后被调用，value 或 reason 依次作为他们的第一个参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">            onFulfilled(this.value);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">            onRejected(this.reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决异步实现"><a href="#解决异步实现" class="headerlink" title="解决异步实现"></a>解决异步实现</h4><p><strong>现在基本可以实现简单的同步代码，但是当 resolve 在 setTimeout 内执行 then 时，state 还是 pending 状态。这时，我们就需要在 then 调用的时候，将成功和失败存到各自的数组，一旦 resolve 或 reject，就调用它们</strong></p>
<p>类似于发布订阅，先将 then 里面的两个函数储存起来，由于一个 Promise 可以有多个 then，所以存在同一个数组内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 多个 then 的情况</span><br><span class="line">let p &#x3D; new Promise();</span><br><span class="line">p.then();</span><br><span class="line">p.then();</span><br></pre></td></tr></table></figure>

<p>成功或失败时，forEach 调用它们</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 成功时存放的数组</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 失败时存放的数组</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F; 一旦 resolve 执行，调用成功数组的函数</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                &#x2F;&#x2F; 一旦 reject 执行，调用失败数组的函数</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">            onFulfilled(this.value);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">            onRejected(this.reason);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; state 为 pending 时</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">            this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                onFulfilled(this.value);</span><br><span class="line">            &#125;);</span><br><span class="line">            this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                onRejected(this.reason);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决链式调用"><a href="#解决链式调用" class="headerlink" title="解决链式调用"></a>解决链式调用</h4><p><strong>我们常常用到 <code>new Promise().then().then()</code>，这就是链式调用，用来解决回调地狱</strong><br>1、为了达成链式，我们默认在第一个 then 里面返回一个 Promise。Promise/A+ 规定了一个方法，就是在 then 里面返回一个新的 Promise，成为 promise2：<code>promise2 = new Promise((resolve, reject) =&gt; {})</code></p>
<ul>
<li>将这个 promise2 返回的值传递到下一个 then 中</li>
<li>如果返回一个普通的值，则将普通的值传递到下一个 then 中</li>
</ul>
<p>2、当我们在第一个 then 中 return 了一个参数(参数未知，需判断)。这个 return 出来的新的 promise 就是 onFulfilled() 或 onRejected() 的值</p>
<p>Promise/A+ 规定 onFulfilled() 或 onRejected() 的值，叫做 x，判断 x 的函数叫做 resolvePromise</p>
<ul>
<li>首先，要看 x 是不是 promise</li>
<li>如果时 promise，则取它的结果，作为新的 promise2 成功的结果</li>
<li>如果是普通值，直接作为 promise2 成功的结果</li>
<li>所以要比较 x 和 promise2 是不是相等</li>
<li>resolvePromise 的参数有 promise2，x，resolve，reject</li>
<li>resolve 和 reject 是 promise2 的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 成功时存放的数组</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 失败时存放的数组</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F; 一旦 resolve 执行，调用成功数组的函数</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                &#x2F;&#x2F; 一旦 reject 执行，调用失败数组的函数</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        let promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">                let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">                let x &#x3D; onRejected(this.reason);</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 pending 时</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;);</span><br><span class="line">                this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    let x &#x3D; onRejected(this.reason);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完成-resovlePromise-函数"><a href="#完成-resovlePromise-函数" class="headerlink" title="完成 resovlePromise 函数"></a>完成 resovlePromise 函数</h4><p>Promise/A+ 规定：</p>
<ol>
<li>如果 x 与 promise2 指向同一对象，会造成循环引用，自己等待自己完成，则以 <code>TypeError</code> 为据因拒绝执行 promise</li>
</ol>
<p>循环引用实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p &#x3D; new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    resolve(1);</span><br><span class="line">&#125;)</span><br><span class="line">let p2 &#x3D; p.then(resolve &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环引用，自己等待自己完成</span><br><span class="line">    return p2;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果 x 为Promise，则使用 promise 接受 x 的状态</p>
</li>
<li><p>否则，x 为对象或函数</p>
</li>
</ol>
<ul>
<li>x 不能是 null</li>
<li>x.then 赋值给 then</li>
<li>如果取 x.then 的值时抛出错误 e，则以 e 为据因拒绝 promise</li>
<li>如果 then 是一个函数，则用 call 执行 then</li>
<li>如果成功的回调还是 promise，就递归继续解析</li>
<li>x 是普通值，则直接 resolve(x)</li>
<li>成功和失败只能调用一个，所以设定一个 called 来防止多次调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环引用直接报错</span><br><span class="line">    if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;</span><br><span class="line">        return reject(new TypeError(&#39;Chaining cycle detected for promise&#39;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 防止多次调用</span><br><span class="line">    let called &#x3D; false;</span><br><span class="line">    if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            let then &#x3D; x.then;</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                then.call(x, y &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, r &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called &#x3D; true;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决其他问题"><a href="#解决其他问题" class="headerlink" title="解决其他问题"></a>解决其他问题</h4><p>Promise/A+ 规定 onFulfilled，onRejected 都是函数，如果不是，则直接被忽略。这里其实应该说如果不是则变为函数，成功时将 value 传递给下一个 then 中的 onFulfilled 中，失败时，直接抛出错误。</p>
<ul>
<li>onFulfilled 返回一个普通的值，直接等于 value =&gt; value</li>
<li>onRejected 返回一个普通的值，直接抛出错误 reason =&gt; throw reason</li>
<li>onFulfilled 或 onRejected 不能同步调用，所以使用 setTimeout 解决</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 成功时存放的数组</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 失败时存放的数组</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F; 一旦 resolve 执行，调用成功数组的函数</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                &#x2F;&#x2F; 一旦 reject 执行，调用失败数组的函数</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : value &#x3D;&gt; value;</span><br><span class="line">        onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : reason &#x3D;&gt; &#123; throw reason &#125;;</span><br><span class="line">        let promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onRejected(this.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 pending 时</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch(e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">                this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x &#x3D; onRejected(this.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch(e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便实现 catch、resolve、reject、race、all方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化状态</span><br><span class="line">        this.state &#x3D; &#39;pending&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功的值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 失败的原因</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F; 成功时存放的数组</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 失败时存放的数组</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; resolve 调用后，state转为成功状态</span><br><span class="line">                this.state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存成功的值</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F; 一旦 resolve 执行，调用成功数组的函数</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; reject 调用后，state转为失败</span><br><span class="line">                this.state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                &#x2F;&#x2F; 储存失败的原因</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                &#x2F;&#x2F; 一旦 reject 执行，调用失败数组的函数</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 executor 失败，直接调用 reject</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 有两个参数 onFulfilled, onRejected</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : value &#x3D;&gt; value;</span><br><span class="line">        onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : reason &#x3D;&gt; &#123; throw reason &#125;;</span><br><span class="line">        let promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; state 为 fulfilled，执行 onFulfilled，传入成功的值</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 rejected onRejected，传入失败的原因</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onRejected(this.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; state 为 pending 时</span><br><span class="line">            if (this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x &#x3D; onFulfilled(this.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch(e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">                this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            let x &#x3D; onRejected(this.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; catch(e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise2;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现 catch 方法</span><br><span class="line">    catch(fn) &#123;</span><br><span class="line">        return this.then(null, fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环引用直接报错</span><br><span class="line">    if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;</span><br><span class="line">        return reject(new TypeError(&#39;Chaining cycle detected for promise&#39;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 防止多次调用</span><br><span class="line">    let called &#x3D; false;</span><br><span class="line">    if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            let then &#x3D; x.then;</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                then.call(x, y &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, r &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called &#x3D; true;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现 resolve 方法</span><br><span class="line">Promise.resolve &#x3D; function(val) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        resolve(val);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现 reject 方法</span><br><span class="line">Promise.reject &#x3D; function(reason) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现 race 方法</span><br><span class="line">Promise.race &#x3D; function(promises) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现 all 方法(获取所有的 promise，都执行 then，把结果放到数组，一起返回)</span><br><span class="line">Promise.all &#x3D; function(promises) &#123;</span><br><span class="line">    let arr &#x3D; [];</span><br><span class="line">    let i &#x3D; 0;</span><br><span class="line">    function processData(index, data) &#123;</span><br><span class="line">        arr[index] &#x3D; data;</span><br><span class="line">        i++;</span><br><span class="line">        if (i &#x3D;&#x3D;&#x3D; promise.length) &#123;</span><br><span class="line">            resolve(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(data &#x3D;&gt; &#123;</span><br><span class="line">                processData(i, data);</span><br><span class="line">            &#125;, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证我们的-Promise-是否正确"><a href="#验证我们的-Promise-是否正确" class="headerlink" title="验证我们的 Promise 是否正确"></a>验证我们的 Promise 是否正确</h4><ul>
<li><p>安装 <code>npm install -g promises-aplus-tests</code></p>
</li>
<li><p>命令行 <code>promises-aplus-test [js文件名].js</code></p>
</li>
<li><p>添加如下代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.defer &#x3D; Promise.deferred &#x3D; function () &#123;</span><br><span class="line">  let dfd &#x3D; &#123;&#125;</span><br><span class="line">  dfd.promise &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    dfd.resolve &#x3D; resolve;</span><br><span class="line">    dfd.reject &#x3D; reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  return dfd;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; Promise;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
</search>
